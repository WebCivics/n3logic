[N3LogicReasoner][TRACE] [N3LogicReasoner] setDebug called: true
[N3LogicReasoner][TRACE] [N3LogicReasoner] setDebug called: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] setDebug finished: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] setDebug finished: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology called: {
  "format": "n3",
  "data": "\n\t\t       <a> <b> \"1\" .\n\t\t       { <a> <b> ?x } => { <a> <c> ?x } .\n\t       "
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology called: {
  "format": "n3",
  "data": "\n\t\t       <a> <b> \"1\" .\n\t\t       { <a> <b> ?x } => { <a> <c> ?x } .\n\t       "
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before loadOntology: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before loadOntology: []
[N3LogicReasoner][DEBUG] Loading ontology {
  "format": "n3",
  "data": "\n\t\t       <a> <b> \"1\" .\n\t\t       { <a> <b> ?x } => { <a> <c> ?x } .\n\t       "
}
[N3LogicReasoner][DEBUG] Loading ontology {
  "format": "n3",
  "data": "\n\t\t       <a> <b> \"1\" .\n\t\t       { <a> <b> ?x } => { <a> <c> ?x } .\n\t       "
}
[N3LogicReasoner][TRACE] [N3LogicParser] parse called: 
		       <a> <b> "1" .
		       { <a> <b> ?x } => { <a> <c> ?x } .
	       
[N3LogicReasoner][TRACE] [N3LogicParser] parse called: 
		       <a> <b> "1" .
		       { <a> <b> ?x } => { <a> <c> ?x } .
	       
[N3LogicReasoner][TRACE] [N3LogicParser] Parsing input 
		       <a> <b> "1" .
		       { <a> <b> ?x } => { <a> <c> ?x } .
	       
[N3LogicReasoner][TRACE] [N3LogicParser] Parsing input 
		       <a> <b> "1" .
		       { <a> <b> ?x } => { <a> <c> ?x } .
	       
[N3LogicParser] Parsing input 
		       <a> <b> "1" .
		       { <a> <b> ?x } => { <a> <c> ?x } .
	       
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Initializing parse loop
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Initializing parse loop
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <b> "1" . { <a> <b> ?x } => { <a> <c> ?x } . false
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <b> "1" . { <a> <b> ?x } => { <a> <c> ?x } . false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicParser] [TRACE][parseTriples] input: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicParser] [TRACE][splitTriples] input: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '"', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '"', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[8] = '"', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = '1', buf='<a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = '1', buf='<a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[9] = '1', buf='<a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[10] = '"', buf='<a> <b> "1', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[10] = '"', buf='<a> <b> "1', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[10] = '"', buf='<a> <b> "1', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[11] = ' ', buf='<a> <b> "1"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[11] = ' ', buf='<a> <b> "1"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[11] = ' ', buf='<a> <b> "1"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[12] = '.', buf='<a> <b> "1" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[12] = '.', buf='<a> <b> "1" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[12] = '.', buf='<a> <b> "1" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: "<a> <b> \"1\" "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: "<a> <b> \"1\" "
[N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: "<a> <b> \"1\" "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"1\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"1\""
[N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"1\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[13] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[13] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[13] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[14] = '{', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[14] = '{', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[14] = '{', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[15] = ' ', buf=' {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[15] = ' ', buf=' {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[15] = ' ', buf=' {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[16] = '<', buf=' { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[16] = '<', buf=' { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[16] = '<', buf=' { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[17] = 'a', buf=' { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[17] = 'a', buf=' { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[17] = 'a', buf=' { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[18] = '>', buf=' { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[18] = '>', buf=' { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[18] = '>', buf=' { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[19] = ' ', buf=' { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[19] = ' ', buf=' { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[19] = ' ', buf=' { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[20] = '<', buf=' { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[20] = '<', buf=' { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[20] = '<', buf=' { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[21] = 'b', buf=' { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[21] = 'b', buf=' { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[21] = 'b', buf=' { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[22] = '>', buf=' { <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[22] = '>', buf=' { <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[22] = '>', buf=' { <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[23] = ' ', buf=' { <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[23] = ' ', buf=' { <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[23] = ' ', buf=' { <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[24] = '?', buf=' { <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[24] = '?', buf=' { <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[24] = '?', buf=' { <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[25] = 'x', buf=' { <a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[25] = 'x', buf=' { <a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[25] = 'x', buf=' { <a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[26] = ' ', buf=' { <a> <b> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[26] = ' ', buf=' { <a> <b> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[26] = ' ', buf=' { <a> <b> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[27] = '}', buf=' { <a> <b> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[27] = '}', buf=' { <a> <b> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[27] = '}', buf=' { <a> <b> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[28] = ' ', buf=' { <a> <b> ?x }', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[28] = ' ', buf=' { <a> <b> ?x }', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[28] = ' ', buf=' { <a> <b> ?x }', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[29] = '=', buf=' { <a> <b> ?x } ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[29] = '=', buf=' { <a> <b> ?x } ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[29] = '=', buf=' { <a> <b> ?x } ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[30] = '>', buf=' { <a> <b> ?x } =', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[30] = '>', buf=' { <a> <b> ?x } =', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[30] = '>', buf=' { <a> <b> ?x } =', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[31] = ' ', buf=' { <a> <b> ?x } =>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[31] = ' ', buf=' { <a> <b> ?x } =>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[31] = ' ', buf=' { <a> <b> ?x } =>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[32] = '{', buf=' { <a> <b> ?x } => ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[32] = '{', buf=' { <a> <b> ?x } => ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[32] = '{', buf=' { <a> <b> ?x } => ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[33] = ' ', buf=' { <a> <b> ?x } => {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[33] = ' ', buf=' { <a> <b> ?x } => {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[33] = ' ', buf=' { <a> <b> ?x } => {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[34] = '<', buf=' { <a> <b> ?x } => { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[34] = '<', buf=' { <a> <b> ?x } => { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[34] = '<', buf=' { <a> <b> ?x } => { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[35] = 'a', buf=' { <a> <b> ?x } => { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[35] = 'a', buf=' { <a> <b> ?x } => { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[35] = 'a', buf=' { <a> <b> ?x } => { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[36] = '>', buf=' { <a> <b> ?x } => { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[36] = '>', buf=' { <a> <b> ?x } => { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[36] = '>', buf=' { <a> <b> ?x } => { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[37] = ' ', buf=' { <a> <b> ?x } => { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[37] = ' ', buf=' { <a> <b> ?x } => { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[37] = ' ', buf=' { <a> <b> ?x } => { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[38] = '<', buf=' { <a> <b> ?x } => { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[38] = '<', buf=' { <a> <b> ?x } => { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[38] = '<', buf=' { <a> <b> ?x } => { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[39] = 'c', buf=' { <a> <b> ?x } => { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[39] = 'c', buf=' { <a> <b> ?x } => { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[39] = 'c', buf=' { <a> <b> ?x } => { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[40] = '>', buf=' { <a> <b> ?x } => { <a> <c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[40] = '>', buf=' { <a> <b> ?x } => { <a> <c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[40] = '>', buf=' { <a> <b> ?x } => { <a> <c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[41] = ' ', buf=' { <a> <b> ?x } => { <a> <c>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[41] = ' ', buf=' { <a> <b> ?x } => { <a> <c>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[41] = ' ', buf=' { <a> <b> ?x } => { <a> <c>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[42] = '?', buf=' { <a> <b> ?x } => { <a> <c> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[42] = '?', buf=' { <a> <b> ?x } => { <a> <c> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[42] = '?', buf=' { <a> <b> ?x } => { <a> <c> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[43] = 'x', buf=' { <a> <b> ?x } => { <a> <c> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[43] = 'x', buf=' { <a> <b> ?x } => { <a> <c> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[43] = 'x', buf=' { <a> <b> ?x } => { <a> <c> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[44] = ' ', buf=' { <a> <b> ?x } => { <a> <c> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[44] = ' ', buf=' { <a> <b> ?x } => { <a> <c> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[44] = ' ', buf=' { <a> <b> ?x } => { <a> <c> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[45] = '}', buf=' { <a> <b> ?x } => { <a> <c> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[45] = '}', buf=' { <a> <b> ?x } => { <a> <c> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[45] = '}', buf=' { <a> <b> ?x } => { <a> <c> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[46] = ' ', buf=' { <a> <b> ?x } => { <a> <c> ?x }', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[46] = ' ', buf=' { <a> <b> ?x } => { <a> <c> ?x }', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[46] = ' ', buf=' { <a> <b> ?x } => { <a> <c> ?x }', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[47] = '.', buf=' { <a> <b> ?x } => { <a> <c> ?x } ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[47] = '.', buf=' { <a> <b> ?x } => { <a> <c> ?x } ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[47] = '.', buf=' { <a> <b> ?x } => { <a> <c> ?x } ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " { <a> <b> ?x } => { <a> <c> ?x } "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " { <a> <b> ?x } => { <a> <c> ?x } "
[N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " { <a> <b> ?x } => { <a> <c> ?x } "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "{ <a> <b> ?x } => { <a> <c> ?x }"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "{ <a> <b> ?x } => { <a> <c> ?x }"
[N3LogicParser] [TRACE][splitTriples] Found triple statement: "{ <a> <b> ?x } => { <a> <c> ?x }"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Skipping final empty/whitespace-only buffer: ""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Skipping final empty/whitespace-only buffer: ""
[N3LogicParser] [TRACE][splitTriples] Skipping final empty/whitespace-only buffer: ""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> \"1\"","{ <a> <b> ?x } => { <a> <c> ?x }"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> \"1\"","{ <a> <b> ?x } => { <a> <c> ?x }"]
[N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> \"1\"","{ <a> <b> ?x } => { <a> <c> ?x }"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> \"1\"","{ <a> <b> ?x } => { <a> <c> ?x }"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> \"1\"","{ <a> <b> ?x } => { <a> <c> ?x }"]
[N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> \"1\"","{ <a> <b> ?x } => { <a> <c> ?x }"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"1\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"1\""
[N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"1\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"1\""]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"1\""]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"1\""]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "1"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "1"
[N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "1"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: "1"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: "1"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"}}
[N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "{ <a> <b> ?x } => { <a> <c> ?x }"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "{ <a> <b> ?x } => { <a> <c> ?x }"
[N3LogicParser] [TRACE][parseTriples] parsing statement: "{ <a> <b> ?x } => { <a> <c> ?x }"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["{","<a>","<b>","?x","}","=>","{","<a>","<c>","?x","}"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["{","<a>","<b>","?x","}","=>","{","<a>","<c>","?x","}"]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["{","<a>","<b>","?x","}","=>","{","<a>","<c>","?x","}"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 11 [
  "{",
  "<a>",
  "<b>",
  "?x",
  "}",
  "=>",
  "{",
  "<a>",
  "<c>",
  "?x",
  "}"
]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 11 [
  "{",
  "<a>",
  "<b>",
  "?x",
  "}",
  "=>",
  "{",
  "<a>",
  "<c>",
  "?x",
  "}"
]
[N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 11 [
  "{",
  "<a>",
  "<b>",
  "?x",
  "}",
  "=>",
  "{",
  "<a>",
  "<c>",
  "?x",
  "}"
]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <b>
[N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <b>
[N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: ?x } =>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: ?x } =>
[N3LogicParser] [TRACE][parseTriples] Triple tokens: ?x } =>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: ?x } =>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: ?x } =>
[N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: ?x } =>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <c>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <c>
[N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <c>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <c>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <c>
[N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <c>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"}}]
[N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicParser] N3LogicParser: Parsed triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] parseRules called: 
		       <a> <b> "1" .
		       { <a> <b> ?x } => { <a> <c> ?x } .
	       
[N3LogicReasoner][TRACE] [N3LogicParser] parseRules called: 
		       <a> <b> "1" .
		       { <a> <b> ?x } => { <a> <c> ?x } .
	       
[N3LogicReasoner][TRACE] [RuleExtractor] extractRules called: 
		       <a> <b> "1" .
		       { <a> <b> ?x } => { <a> <c> ?x } .
	       
[N3LogicReasoner][TRACE] [RuleExtractor] extractRules called: 
		       <a> <b> "1" .
		       { <a> <b> ?x } => { <a> <c> ?x } .
	       
[parseRules][DEBUG] antecedent string: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <b> ?x true
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <b> ?x true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <b> ?x"
[N3LogicParser] [TRACE][parseTriples] input: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> ?x"
[N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <b> ?x"
[N3LogicParser] [TRACE][splitTriples] input: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '?', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '?', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[8] = '?', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = 'x', buf='<a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = 'x', buf='<a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[9] = 'x', buf='<a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found final triple statement: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found final triple statement: "<a> <b> ?x"
[N3LogicParser] [TRACE][splitTriples] Found final triple statement: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> ?x"]
[N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> ?x"]
[N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> ?x"
[N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","?x"]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> ?x
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> ?x
[N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> ?x
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: ?x
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: ?x
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN VAR] ?x {"type":"Variable","value":"x"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN VAR] ?x {"type":"Variable","value":"x"}
[N3LogicParser] [parseTerm][RETURN VAR] ?x {"type":"Variable","value":"x"}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]
[N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <c> ?x true
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <c> ?x true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <c> ?x"
[N3LogicParser] [TRACE][parseTriples] input: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <c> ?x"
[N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <c> ?x"
[N3LogicParser] [TRACE][splitTriples] input: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'c', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'c', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[5] = 'c', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <c>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <c>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <c>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '?', buf='<a> <c> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '?', buf='<a> <c> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[8] = '?', buf='<a> <c> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = 'x', buf='<a> <c> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = 'x', buf='<a> <c> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[9] = 'x', buf='<a> <c> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found final triple statement: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found final triple statement: "<a> <c> ?x"
[N3LogicParser] [TRACE][splitTriples] Found final triple statement: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <c> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <c> ?x"]
[N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <c> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <c> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <c> ?x"]
[N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <c> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <c> ?x"
[N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<c>","?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<c>","?x"]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<c>","?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <c> ?x
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <c> ?x
[N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <c> ?x
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <c>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <c>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <c> {"type":"IRI","value":"c"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <c> {"type":"IRI","value":"c"}
[N3LogicParser] [parseTerm][RETURN IRI] <c> {"type":"IRI","value":"c"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: ?x
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: ?x
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN VAR] ?x {"type":"Variable","value":"x"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN VAR] ?x {"type":"Variable","value":"x"}
[N3LogicParser] [parseTerm][RETURN VAR] ?x {"type":"Variable","value":"x"}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}
[N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: c
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: c
[N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: c
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]
[N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] [parseRules][DEBUG][CUSTOM] Parsed rule antecedent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] [parseRules][DEBUG][CUSTOM] Parsed rule antecedent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicParser] [parseRules][DEBUG][CUSTOM] Parsed rule antecedent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] [parseRules][DEBUG][CUSTOM] Parsed rule consequent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] [parseRules][DEBUG][CUSTOM] Parsed rule consequent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicParser] [parseRules][DEBUG][CUSTOM] Parsed rule consequent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicParser] N3LogicParser: Parsed rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] parseBuiltins called: 
		       <a> <b> "1" .
		       { <a> <b> ?x } => { <a> <c> ?x } .
	       
[N3LogicReasoner][TRACE] [N3LogicParser] parseBuiltins called: 
		       <a> <b> "1" .
		       { <a> <b> ?x } => { <a> <c> ?x } .
	       
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed builtins: []
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed builtins: []
[N3LogicParser] N3LogicParser: Parsed builtins: []
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Parsing loop complete, triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
] rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Parsing loop complete, triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
] rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: parsedDoc {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ],
  "rules": [
    {
      "type": "Rule",
      "antecedent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "b"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      },
      "consequent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "c"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      }
    }
  ],
  "builtins": []
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: parsedDoc {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ],
  "rules": [
    {
      "type": "Rule",
      "antecedent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "b"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      },
      "consequent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "c"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      }
    }
  ],
  "builtins": []
}
[N3LogicReasoner][DEBUG] N3LogicReasoner: Parsed rules after parsing: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][DEBUG] N3LogicReasoner: Parsed rules after parsing: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] Parsed triples after parsing: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] Parsed triples after parsing: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] N3LogicReasoner: Rule #0 antecedent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] N3LogicReasoner: Rule #0 antecedent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] N3LogicReasoner: Rule #0 consequent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] N3LogicReasoner: Rule #0 consequent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: merging builtins []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: merging builtins []
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: document.builtins after merge [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: document.builtins after merge [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins after loadOntology: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins after loadOntology: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] document.builtins after loadOntology: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] document.builtins after loadOntology: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] Parsed rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][DEBUG] Parsed rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterLoadOntology [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        }
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterLoadOntology [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        }
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterLoadOntology args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        }
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterLoadOntology args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        }
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterLoadOntology",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "1"
          }
        }
      ],
      "rules": [
        {
          "type": "Rule",
          "antecedent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "b"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          },
          "consequent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "c"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          }
        }
      ],
      "builtins": [
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterLoadOntology",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "1"
          }
        }
      ],
      "rules": [
        {
          "type": "Rule",
          "antecedent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "b"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          },
          "consequent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "c"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          }
        }
      ],
      "builtins": [
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterLoadOntology
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterLoadOntology
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterLoadOntology
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterLoadOntology
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology finished
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology finished
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason() called
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason() called
[N3LogicReasoner][DEBUG] [REASONER] Starting reason() method. Current builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [REASONER] Starting reason() method. Current builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: merging builtins []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: merging builtins []
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: document.builtins after merge [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: document.builtins after merge [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before reasoning: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before reasoning: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins before reasoning: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins before reasoning: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] Merged builtins for reasoning: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] Merged builtins for reasoning: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] Starting reasoning {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ],
  "rules": [
    {
      "type": "Rule",
      "antecedent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "b"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      },
      "consequent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "c"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      }
    }
  ]
}
[N3LogicReasoner][DEBUG] Starting reasoning {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ],
  "rules": [
    {
      "type": "Rule",
      "antecedent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "b"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      },
      "consequent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "c"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      }
    }
  ]
}
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: beforeReason [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        },
        "_id": 1,
        "_provenance": "asserted"
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: beforeReason [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        },
        "_id": 1,
        "_provenance": "asserted"
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: beforeReason args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        },
        "_id": 1,
        "_provenance": "asserted"
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: beforeReason args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        },
        "_id": 1,
        "_provenance": "asserted"
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "beforeReason",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "1"
          },
          "_id": 1,
          "_provenance": "asserted"
        }
      ],
      "rules": [
        {
          "type": "Rule",
          "antecedent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "b"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          },
          "consequent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "c"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          }
        }
      ],
      "builtins": [
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "beforeReason",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "1"
          },
          "_id": 1,
          "_provenance": "asserted"
        }
      ],
      "rules": [
        {
          "type": "Rule",
          "antecedent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "b"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          },
          "consequent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "c"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          }
        }
      ],
      "builtins": [
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for beforeReason
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook beforeReason
[N3LogicReasoner][DEBUG] Initial working triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] Initial working triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <b> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <b> "1" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <b> "1" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <b> "1" .
[N3LogicReasoner][DEBUG] Adding initial triple to inferred set: <a> <b> "1" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][DEBUG] Adding initial triple to inferred set: <a> <b> "1" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Reasoning iteration 1 START
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Reasoning iteration 1 START
[N3LogicReasoner][DEBUG] 
=== Reasoning iteration 1 START ===
[N3LogicReasoner][DEBUG] 
=== Reasoning iteration 1 START ===
[N3LogicReasoner][DEBUG] Current triple store at start of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] Current triple store at start of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Evaluating rule #0
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Evaluating rule #0
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Evaluating rule #0: {"type":"Rule","antecedent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]},"consequent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Evaluating rule #0: {"type":"Rule","antecedent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]},"consequent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]}}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Matching antecedent for rule #0
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Matching antecedent for rule #0
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Matching antecedent for rule #0: {"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Matching antecedent for rule #0: {"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]}
[N3LogicReasoner][TRACE] matchFormula called {
  "formula": {
    "type": "Formula",
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Variable",
          "value": "x"
        }
      }
    ]
  },
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] matchFormula called {
  "formula": {
    "type": "Formula",
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Variable",
          "value": "x"
        }
      }
    ]
  },
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] Formula type is Formula, matching antecedent: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] Formula type is Formula, matching antecedent: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent called: {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent called: {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent called with: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}] [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent called with: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}] [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Checking pattern triple # 0 : {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Checking pattern triple # 0 : {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Pattern triple details: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Pattern triple details: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Triple matching logic entered: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Triple matching logic entered: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Attempting builtin match for triple predicate: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Attempting builtin match for triple predicate: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] All builtins at this point: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] All builtins at this point: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin candidate URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin candidate URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin match found for predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin match found for predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin match found for predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin match found for predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtin found: false for predicateUri: b triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtin found: false for predicateUri: b triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin found: false for predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin found: false for predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][TRACE] matchTriple called {
  "pattern": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
}
[N3LogicReasoner][TRACE] matchTriple called {
  "pattern": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "a"
  },
  "value": {
    "type": "IRI",
    "value": "a"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "a"
  },
  "value": {
    "type": "IRI",
    "value": "a"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "a"
} {
  "type": "IRI",
  "value": "a"
}
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "a"
} {
  "type": "IRI",
  "value": "a"
}
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "b"
  },
  "value": {
    "type": "IRI",
    "value": "b"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "b"
  },
  "value": {
    "type": "IRI",
    "value": "b"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "b"
}
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "b"
}
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "Variable",
    "value": "x"
  },
  "value": {
    "type": "Literal",
    "value": "1"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "Variable",
    "value": "x"
  },
  "value": {
    "type": "Literal",
    "value": "1"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is variable: x
[N3LogicReasoner][TRACE] Pattern is variable: x
[N3LogicReasoner][TRACE] Binding variable: x to value: {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][TRACE] Binding variable: x to value: {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][TRACE] matchTriple succeeded, bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] matchTriple succeeded, bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data triple matched: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"} bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data triple matched: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"} bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Data triple matched: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
} bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Data triple matched: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
} bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: []
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: []
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: patterns: []
[N3LogicReasoner][TRACE] matchAntecedent: patterns: []
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] No patterns left, returning [{}]
[N3LogicReasoner][TRACE] No patterns left, returning [{}]
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Added result bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Added result bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] matchAntecedent returning results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] matchAntecedent returning results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent returning results: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent returning results: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent result: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent result: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent result: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent result: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings list from matchFormula for rule #0: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings list from matchFormula for rule #0: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings list from matchFormula for rule #0: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings list from matchFormula for rule #0: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings #0 before evaluateBuiltins for rule #0: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings #0 before evaluateBuiltins for rule #0: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings #0 before evaluateBuiltins for rule #0: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings #0 before evaluateBuiltins for rule #0: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins called: {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins called: {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] evaluateBuiltins: triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] evaluateBuiltins: bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins called {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][DEBUG] evaluateBuiltins called {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking builtin for predicate: b Found: false Function:  Typeof: 
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking builtin for predicate: b Found: false Function:  Typeof: 
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins returning true
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins returning true
[N3LogicReasoner][DEBUG] evaluateBuiltins returning true
[N3LogicReasoner][DEBUG] evaluateBuiltins returning true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiating consequent triple #0 for rule #0
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiating consequent triple #0 for rule #0
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiating consequent triple #0 for rule #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}} with bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiating consequent triple #0 for rule #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}} with bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple called: {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple called: {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][DEBUG] instantiateTriple called {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][DEBUG] instantiateTriple called {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][DEBUG] Substituting variable in triple: x with {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][DEBUG] Substituting variable in triple: x with {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][DEBUG] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiated triple for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiated triple for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiated triple for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiated triple for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <c> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <c> "1" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <c> "1" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <c> "1" .
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Adding new inferred triple for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
} Key: <a> <c> "1" .
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Adding new inferred triple for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
} Key: <a> <c> "1" .
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Adding new inferred triple for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}} Key: <a> <c> "1" .
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Adding new inferred triple for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}} Key: <a> <c> "1" .
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterRuleApplied [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  },
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterRuleApplied [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  },
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterRuleApplied args: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  },
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterRuleApplied args: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  },
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterRuleApplied",
  "args": [
    {
      "type": "Rule",
      "antecedent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "b"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      },
      "consequent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "c"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      }
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    },
    {
      "x": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterRuleApplied",
  "args": [
    {
      "type": "Rule",
      "antecedent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "b"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      },
      "consequent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "c"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      }
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    },
    {
      "x": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterRuleApplied
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterRuleApplied
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterRuleApplied
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterRuleApplied
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] New triples inferred in iteration 1: [
  "<a> <c> \"1\" ."
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] New triples inferred in iteration 1: [
  "<a> <c> \"1\" ."
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] New triples inferred in iteration 1: [
  "<a> <c> \"1\" ."
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] New triples inferred in iteration 1: [
  "<a> <c> \"1\" ."
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Rules fired in iteration 1: [
  0
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Rules fired in iteration 1: [
  0
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Rules fired in iteration 1: [
  0
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Rules fired in iteration 1: [
  0
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] === Reasoning iteration 1 END. changed=true ===
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] === Reasoning iteration 1 END. changed=true ===
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] === Reasoning iteration 1 END. changed=true ===

[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] === Reasoning iteration 1 END. changed=true ===

[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Reasoning iteration 2 START
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Reasoning iteration 2 START
[N3LogicReasoner][DEBUG] 
=== Reasoning iteration 2 START ===
[N3LogicReasoner][DEBUG] 
=== Reasoning iteration 2 START ===
[N3LogicReasoner][DEBUG] Current triple store at start of iteration 2: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] Current triple store at start of iteration 2: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Evaluating rule #0
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Evaluating rule #0
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Evaluating rule #0: {"type":"Rule","antecedent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]},"consequent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Evaluating rule #0: {"type":"Rule","antecedent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]},"consequent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]}}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Matching antecedent for rule #0
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Matching antecedent for rule #0
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Matching antecedent for rule #0: {"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Matching antecedent for rule #0: {"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]}
[N3LogicReasoner][TRACE] matchFormula called {
  "formula": {
    "type": "Formula",
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Variable",
          "value": "x"
        }
      }
    ]
  },
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] matchFormula called {
  "formula": {
    "type": "Formula",
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Variable",
          "value": "x"
        }
      }
    ]
  },
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] Formula type is Formula, matching antecedent: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] Formula type is Formula, matching antecedent: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent called: {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent called: {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent called with: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}] [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"},{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent called with: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}] [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"},{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Checking pattern triple # 0 : {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Checking pattern triple # 0 : {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Pattern triple details: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Pattern triple details: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Triple matching logic entered: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Triple matching logic entered: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Attempting builtin match for triple predicate: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Attempting builtin match for triple predicate: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] All builtins at this point: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] All builtins at this point: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin candidate URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin candidate URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin match found for predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin match found for predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin match found for predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin match found for predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtin found: false for predicateUri: b triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtin found: false for predicateUri: b triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin found: false for predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin found: false for predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][TRACE] matchTriple called {
  "pattern": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
}
[N3LogicReasoner][TRACE] matchTriple called {
  "pattern": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "a"
  },
  "value": {
    "type": "IRI",
    "value": "a"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "a"
  },
  "value": {
    "type": "IRI",
    "value": "a"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "a"
} {
  "type": "IRI",
  "value": "a"
}
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "a"
} {
  "type": "IRI",
  "value": "a"
}
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "b"
  },
  "value": {
    "type": "IRI",
    "value": "b"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "b"
  },
  "value": {
    "type": "IRI",
    "value": "b"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "b"
}
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "b"
}
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "Variable",
    "value": "x"
  },
  "value": {
    "type": "Literal",
    "value": "1"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "Variable",
    "value": "x"
  },
  "value": {
    "type": "Literal",
    "value": "1"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is variable: x
[N3LogicReasoner][TRACE] Pattern is variable: x
[N3LogicReasoner][TRACE] Binding variable: x to value: {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][TRACE] Binding variable: x to value: {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][TRACE] matchTriple succeeded, bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] matchTriple succeeded, bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data triple matched: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"} bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data triple matched: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"} bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Data triple matched: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
} bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Data triple matched: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
} bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: []
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: []
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: patterns: []
[N3LogicReasoner][TRACE] matchAntecedent: patterns: []
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] No patterns left, returning [{}]
[N3LogicReasoner][TRACE] No patterns left, returning [{}]
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Added result bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Added result bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] matchTriple called {
  "pattern": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][TRACE] matchTriple called {
  "pattern": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "a"
  },
  "value": {
    "type": "IRI",
    "value": "a"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "a"
  },
  "value": {
    "type": "IRI",
    "value": "a"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "a"
} {
  "type": "IRI",
  "value": "a"
}
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "a"
} {
  "type": "IRI",
  "value": "a"
}
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "b"
  },
  "value": {
    "type": "IRI",
    "value": "c"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "b"
  },
  "value": {
    "type": "IRI",
    "value": "c"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "c"
}
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "c"
}
[N3LogicReasoner][TRACE] termEquals: object equality false
[N3LogicReasoner][TRACE] termEquals: object equality false
[N3LogicReasoner][TRACE] matchTriple: predicate did not match {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "c"
}
[N3LogicReasoner][TRACE] matchTriple: predicate did not match {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "c"
}
[N3LogicReasoner][DEBUG] matchAntecedent returning results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] matchAntecedent returning results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent returning results: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent returning results: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent result: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent result: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent result: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent result: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings list from matchFormula for rule #0: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings list from matchFormula for rule #0: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings list from matchFormula for rule #0: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings list from matchFormula for rule #0: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings #0 before evaluateBuiltins for rule #0: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings #0 before evaluateBuiltins for rule #0: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings #0 before evaluateBuiltins for rule #0: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings #0 before evaluateBuiltins for rule #0: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins called: {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins called: {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] evaluateBuiltins: triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] evaluateBuiltins: bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins called {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][DEBUG] evaluateBuiltins called {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking builtin for predicate: b Found: false Function:  Typeof: 
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking builtin for predicate: b Found: false Function:  Typeof: 
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins returning true
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins returning true
[N3LogicReasoner][DEBUG] evaluateBuiltins returning true
[N3LogicReasoner][DEBUG] evaluateBuiltins returning true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiating consequent triple #0 for rule #0
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiating consequent triple #0 for rule #0
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiating consequent triple #0 for rule #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}} with bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiating consequent triple #0 for rule #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}} with bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple called: {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple called: {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][DEBUG] instantiateTriple called {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][DEBUG] instantiateTriple called {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][DEBUG] Substituting variable in triple: x with {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][DEBUG] Substituting variable in triple: x with {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][DEBUG] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiated triple for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiated triple for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiated triple for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiated triple for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <c> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <c> "1" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <c> "1" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <c> "1" .
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Triple already present, skipping for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
} Key: <a> <c> "1" .
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Triple already present, skipping for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
} Key: <a> <c> "1" .
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Triple already present, skipping for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}} Key: <a> <c> "1" .
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Triple already present, skipping for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}} Key: <a> <c> "1" .
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] New triples inferred in iteration 2: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] New triples inferred in iteration 2: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] New triples inferred in iteration 2: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] New triples inferred in iteration 2: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Rules fired in iteration 2: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Rules fired in iteration 2: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Rules fired in iteration 2: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Rules fired in iteration 2: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Current triple store at end of iteration 2: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Current triple store at end of iteration 2: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Current triple store at end of iteration 2: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Current triple store at end of iteration 2: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] === Reasoning iteration 2 END. changed=false ===
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] === Reasoning iteration 2 END. changed=false ===
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] === Reasoning iteration 2 END. changed=false ===

[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] === Reasoning iteration 2 END. changed=false ===

[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterReason [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterReason [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterReason args: [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterReason args: [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterReason",
  "args": [
    [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "c"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        }
      }
    ]
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterReason",
  "args": [
    [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "c"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        }
      }
    ]
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterReason
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook afterReason
[N3LogicReasoner][DEBUG] Reasoning complete. Inferred triples: [
  "<a> <b> \"1\" .",
  "<a> <c> \"1\" ."
]
[N3LogicReasoner][DEBUG] Reasoning complete. Inferred triples: [
  "<a> <b> \"1\" .",
  "<a> <c> \"1\" ."
]
[N3LogicReasoner][TRACE] stringToTriple input: <a> <b> "1" .
[N3LogicReasoner][TRACE] stringToTriple input: <a> <b> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <b> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <b> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<b>",
  "object": "\"1\""
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<b>",
  "object": "\"1\""
}
[N3LogicReasoner][TRACE] stringToTriple input: <a> <c> "1" .
[N3LogicReasoner][TRACE] stringToTriple input: <a> <c> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <c> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <c> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<c>",
  "object": "\"1\""
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<c>",
  "object": "\"1\""
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: finished, returning result
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: finished, returning result
[TEST reasoner] All inferred triples: [
  "<a> <b> \"1\" .",
  "<a> <c> \"1\" ."
]
[TEST reasoner] Inferred triple for predicate c: <a> <c> "1" .
[N3LogicReasoner][TRACE] [N3LogicReasoner] setDebug called: true
[N3LogicReasoner][TRACE] [N3LogicReasoner] setDebug called: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] setDebug finished: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] setDebug finished: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin called: {
  "uri": "http://example.org/custom#isFoo",
  "arity": 1,
  "description": "Returns true if the subject is the literal \"foo\""
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin called: {
  "uri": "http://example.org/custom#isFoo",
  "arity": 1,
  "description": "Returns true if the subject is the literal \"foo\""
}
[N3LogicReasoner][DEBUG] Reasoner: All triples at start: []
[N3LogicReasoner][DEBUG] Reasoner: All triples at start: []
[N3LogicReasoner][DEBUG] Reasoner: All rules at start: []
[N3LogicReasoner][DEBUG] Reasoner: All rules at start: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Builtins before registerBuiltin: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Builtins before registerBuiltin: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin: customBuiltins after push [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin: customBuiltins after push [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][PATCHED] customBuiltins after push: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][PATCHED] customBuiltins after push: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin: merging builtins [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin: merging builtins [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
] Resulting merged builtins: [
  {
    "uri": "http://example.org/custom#isFoo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
] Resulting merged builtins: [
  {
    "uri": "http://example.org/custom#isFoo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin: document.builtins after merge [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin: document.builtins after merge [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][PATCHED] Builtins after registerBuiltin: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][PATCHED] Builtins after registerBuiltin: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][PATCHED] customBuiltins after registerBuiltin: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][PATCHED] customBuiltins after registerBuiltin: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin finished
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin finished
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology called: {
  "format": "n3",
  "data": "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } ."
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology called: {
  "format": "n3",
  "data": "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } ."
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before loadOntology: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before loadOntology: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] Loading ontology {
  "format": "n3",
  "data": "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } ."
}
[N3LogicReasoner][DEBUG] Loading ontology {
  "format": "n3",
  "data": "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } ."
}
[N3LogicReasoner][TRACE] [N3LogicParser] parse called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } .
[N3LogicReasoner][TRACE] [N3LogicParser] parse called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } .
[N3LogicReasoner][TRACE] [N3LogicParser] Parsing input <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } .
[N3LogicReasoner][TRACE] [N3LogicParser] Parsing input <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } .
[N3LogicParser] Parsing input <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } .
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Initializing parse loop
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Initializing parse loop
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom false
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicParser] [TRACE][parseTriples] input: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicParser] [TRACE][splitTriples] input: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '"', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '"', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[8] = '"', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = 'f', buf='<a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = 'f', buf='<a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[9] = 'f', buf='<a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[10] = 'o', buf='<a> <b> "f', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[10] = 'o', buf='<a> <b> "f', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[10] = 'o', buf='<a> <b> "f', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[11] = 'o', buf='<a> <b> "fo', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[11] = 'o', buf='<a> <b> "fo', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[11] = 'o', buf='<a> <b> "fo', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[12] = '"', buf='<a> <b> "foo', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[12] = '"', buf='<a> <b> "foo', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[12] = '"', buf='<a> <b> "foo', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[13] = ' ', buf='<a> <b> "foo"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[13] = ' ', buf='<a> <b> "foo"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[13] = ' ', buf='<a> <b> "foo"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[14] = '.', buf='<a> <b> "foo" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[14] = '.', buf='<a> <b> "foo" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[14] = '.', buf='<a> <b> "foo" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: "<a> <b> \"foo\" "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: "<a> <b> \"foo\" "
[N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: "<a> <b> \"foo\" "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"foo\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"foo\""
[N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"foo\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[15] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[15] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[15] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[16] = '<', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[16] = '<', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[16] = '<', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[17] = 'a', buf=' <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[17] = 'a', buf=' <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[17] = 'a', buf=' <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[18] = '>', buf=' <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[18] = '>', buf=' <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[18] = '>', buf=' <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[19] = ' ', buf=' <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[19] = ' ', buf=' <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[19] = ' ', buf=' <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[20] = '<', buf=' <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[20] = '<', buf=' <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[20] = '<', buf=' <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[21] = 'b', buf=' <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[21] = 'b', buf=' <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[21] = 'b', buf=' <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[22] = '>', buf=' <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[22] = '>', buf=' <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[22] = '>', buf=' <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[23] = ' ', buf=' <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[23] = ' ', buf=' <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[23] = ' ', buf=' <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[24] = '"', buf=' <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[24] = '"', buf=' <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[24] = '"', buf=' <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[25] = 'b', buf=' <a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[25] = 'b', buf=' <a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[25] = 'b', buf=' <a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[26] = 'a', buf=' <a> <b> "b', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[26] = 'a', buf=' <a> <b> "b', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[26] = 'a', buf=' <a> <b> "b', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[27] = 'r', buf=' <a> <b> "ba', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[27] = 'r', buf=' <a> <b> "ba', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[27] = 'r', buf=' <a> <b> "ba', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[28] = '"', buf=' <a> <b> "bar', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[28] = '"', buf=' <a> <b> "bar', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[28] = '"', buf=' <a> <b> "bar', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[29] = ' ', buf=' <a> <b> "bar"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[29] = ' ', buf=' <a> <b> "bar"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[29] = ' ', buf=' <a> <b> "bar"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[30] = '.', buf=' <a> <b> "bar" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[30] = '.', buf=' <a> <b> "bar" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[30] = '.', buf=' <a> <b> "bar" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " <a> <b> \"bar\" "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " <a> <b> \"bar\" "
[N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " <a> <b> \"bar\" "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"bar\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"bar\""
[N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"bar\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[31] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[31] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[31] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[32] = '{', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[32] = '{', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[32] = '{', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[33] = ' ', buf=' {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[33] = ' ', buf=' {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[33] = ' ', buf=' {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[34] = '<', buf=' { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[34] = '<', buf=' { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[34] = '<', buf=' { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[35] = 'a', buf=' { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[35] = 'a', buf=' { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[35] = 'a', buf=' { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[36] = '>', buf=' { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[36] = '>', buf=' { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[36] = '>', buf=' { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[37] = ' ', buf=' { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[37] = ' ', buf=' { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[37] = ' ', buf=' { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[38] = '<', buf=' { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[38] = '<', buf=' { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[38] = '<', buf=' { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[39] = 'b', buf=' { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[39] = 'b', buf=' { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[39] = 'b', buf=' { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[40] = '>', buf=' { <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[40] = '>', buf=' { <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[40] = '>', buf=' { <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[41] = ' ', buf=' { <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[41] = ' ', buf=' { <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[41] = ' ', buf=' { <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[42] = '?', buf=' { <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[42] = '?', buf=' { <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[42] = '?', buf=' { <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[43] = 'x', buf=' { <a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[43] = 'x', buf=' { <a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[43] = 'x', buf=' { <a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[44] = ' ', buf=' { <a> <b> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[44] = ' ', buf=' { <a> <b> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[44] = ' ', buf=' { <a> <b> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[45] = '.', buf=' { <a> <b> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[45] = '.', buf=' { <a> <b> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[45] = '.', buf=' { <a> <b> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " { <a> <b> ?x "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " { <a> <b> ?x "
[N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " { <a> <b> ?x "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "{ <a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "{ <a> <b> ?x"
[N3LogicParser] [TRACE][splitTriples] Found triple statement: "{ <a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[46] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[46] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[46] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[47] = '?', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[47] = '?', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[47] = '?', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[48] = 'x', buf=' ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[48] = 'x', buf=' ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[48] = 'x', buf=' ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[49] = ' ', buf=' ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[49] = ' ', buf=' ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[49] = ' ', buf=' ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[50] = '<', buf=' ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[50] = '<', buf=' ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[50] = '<', buf=' ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[51] = 'h', buf=' ?x <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[51] = 'h', buf=' ?x <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[51] = 'h', buf=' ?x <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[52] = 't', buf=' ?x <h', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[52] = 't', buf=' ?x <h', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[52] = 't', buf=' ?x <h', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[53] = 't', buf=' ?x <ht', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[53] = 't', buf=' ?x <ht', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[53] = 't', buf=' ?x <ht', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[54] = 'p', buf=' ?x <htt', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[54] = 'p', buf=' ?x <htt', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[54] = 'p', buf=' ?x <htt', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[55] = ':', buf=' ?x <http', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[55] = ':', buf=' ?x <http', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[55] = ':', buf=' ?x <http', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[56] = '/', buf=' ?x <http:', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[56] = '/', buf=' ?x <http:', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[56] = '/', buf=' ?x <http:', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[57] = '/', buf=' ?x <http:/', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[57] = '/', buf=' ?x <http:/', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[57] = '/', buf=' ?x <http:/', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[58] = 'e', buf=' ?x <http://', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[58] = 'e', buf=' ?x <http://', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[58] = 'e', buf=' ?x <http://', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[59] = 'x', buf=' ?x <http://e', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[59] = 'x', buf=' ?x <http://e', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[59] = 'x', buf=' ?x <http://e', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[60] = 'a', buf=' ?x <http://ex', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[60] = 'a', buf=' ?x <http://ex', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[60] = 'a', buf=' ?x <http://ex', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[61] = 'm', buf=' ?x <http://exa', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[61] = 'm', buf=' ?x <http://exa', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[61] = 'm', buf=' ?x <http://exa', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[62] = 'p', buf=' ?x <http://exam', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[62] = 'p', buf=' ?x <http://exam', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[62] = 'p', buf=' ?x <http://exam', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[63] = 'l', buf=' ?x <http://examp', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[63] = 'l', buf=' ?x <http://examp', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[63] = 'l', buf=' ?x <http://examp', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[64] = 'e', buf=' ?x <http://exampl', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[64] = 'e', buf=' ?x <http://exampl', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[64] = 'e', buf=' ?x <http://exampl', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[65] = '.', buf=' ?x <http://example', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[65] = '.', buf=' ?x <http://example', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[65] = '.', buf=' ?x <http://example', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[66] = 'o', buf=' ?x <http://example.', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[66] = 'o', buf=' ?x <http://example.', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[66] = 'o', buf=' ?x <http://example.', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[67] = 'r', buf=' ?x <http://example.o', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[67] = 'r', buf=' ?x <http://example.o', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[67] = 'r', buf=' ?x <http://example.o', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[68] = 'g', buf=' ?x <http://example.or', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[68] = 'g', buf=' ?x <http://example.or', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[68] = 'g', buf=' ?x <http://example.or', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[69] = '/', buf=' ?x <http://example.org', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[69] = '/', buf=' ?x <http://example.org', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[69] = '/', buf=' ?x <http://example.org', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[70] = 'c', buf=' ?x <http://example.org/', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[70] = 'c', buf=' ?x <http://example.org/', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[70] = 'c', buf=' ?x <http://example.org/', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[71] = 'u', buf=' ?x <http://example.org/c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[71] = 'u', buf=' ?x <http://example.org/c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[71] = 'u', buf=' ?x <http://example.org/c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[72] = 's', buf=' ?x <http://example.org/cu', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[72] = 's', buf=' ?x <http://example.org/cu', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[72] = 's', buf=' ?x <http://example.org/cu', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[73] = 't', buf=' ?x <http://example.org/cus', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[73] = 't', buf=' ?x <http://example.org/cus', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[73] = 't', buf=' ?x <http://example.org/cus', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[74] = 'o', buf=' ?x <http://example.org/cust', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[74] = 'o', buf=' ?x <http://example.org/cust', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[74] = 'o', buf=' ?x <http://example.org/cust', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[75] = 'm', buf=' ?x <http://example.org/custo', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[75] = 'm', buf=' ?x <http://example.org/custo', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[75] = 'm', buf=' ?x <http://example.org/custo', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found final triple statement: "?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found final triple statement: "?x <http://example.org/custom"
[N3LogicParser] [TRACE][splitTriples] Found final triple statement: "?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> \"foo\"","<a> <b> \"bar\"","{ <a> <b> ?x","?x <http://example.org/custom"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> \"foo\"","<a> <b> \"bar\"","{ <a> <b> ?x","?x <http://example.org/custom"]
[N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> \"foo\"","<a> <b> \"bar\"","{ <a> <b> ?x","?x <http://example.org/custom"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> \"foo\"","<a> <b> \"bar\"","{ <a> <b> ?x","?x <http://example.org/custom"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> \"foo\"","<a> <b> \"bar\"","{ <a> <b> ?x","?x <http://example.org/custom"]
[N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> \"foo\"","<a> <b> \"bar\"","{ <a> <b> ?x","?x <http://example.org/custom"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"foo\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"foo\""
[N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"foo\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"foo\""]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"foo\""]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"foo\""]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "foo"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "foo"
[N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "foo"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: "foo"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: "foo"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"foo"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"foo"}}
[N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"foo"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"bar\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"bar\""
[N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"bar\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"bar\""]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"bar\""]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"bar\""]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "bar"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "bar"
[N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "bar"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: "bar"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: "bar"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"bar"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"bar"}}
[N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"bar"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "{ <a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "{ <a> <b> ?x"
[N3LogicParser] [TRACE][parseTriples] parsing statement: "{ <a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["{","<a>","<b>","?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["{","<a>","<b>","?x"]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["{","<a>","<b>","?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 4 [
  "{",
  "<a>",
  "<b>",
  "?x"
]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 4 [
  "{",
  "<a>",
  "<b>",
  "?x"
]
[N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 4 [
  "{",
  "<a>",
  "<b>",
  "?x"
]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <b>
[N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <b>
[N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "?x <http://example.org/custom"
[N3LogicParser] [TRACE][parseTriples] parsing statement: "?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["?x","<http://example.org/custom"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["?x","<http://example.org/custom"]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["?x","<http://example.org/custom"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 2 [
  "?x",
  "<http://example.org/custom"
]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 2 [
  "?x",
  "<http://example.org/custom"
]
[N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 2 [
  "?x",
  "<http://example.org/custom"
]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"foo"}},{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"bar"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"foo"}},{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"bar"}}]
[N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"foo"}},{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"bar"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
]
[N3LogicParser] N3LogicParser: Parsed triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] parseRules called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom
[N3LogicReasoner][TRACE] [N3LogicParser] parseRules called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom
[N3LogicReasoner][TRACE] [RuleExtractor] extractRules called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom
[N3LogicReasoner][TRACE] [RuleExtractor] extractRules called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed rules: []
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed rules: []
[N3LogicParser] N3LogicParser: Parsed rules: []
[N3LogicReasoner][TRACE] [N3LogicParser] parseBuiltins called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom
[N3LogicReasoner][TRACE] [N3LogicParser] parseBuiltins called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed builtins: []
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed builtins: []
[N3LogicParser] N3LogicParser: Parsed builtins: []
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Parsing loop complete, triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
] rules: []
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Parsing loop complete, triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
] rules: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: parsedDoc {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      }
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      }
    }
  ],
  "rules": [],
  "builtins": []
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: parsedDoc {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      }
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      }
    }
  ],
  "rules": [],
  "builtins": []
}
[N3LogicReasoner][DEBUG] N3LogicReasoner: Parsed rules after parsing: []
[N3LogicReasoner][DEBUG] N3LogicReasoner: Parsed rules after parsing: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] Parsed triples after parsing: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] Parsed triples after parsing: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: merging builtins [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: merging builtins [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
] Resulting merged builtins: [
  {
    "uri": "http://example.org/custom#isFoo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
] Resulting merged builtins: [
  {
    "uri": "http://example.org/custom#isFoo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: document.builtins after merge [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: document.builtins after merge [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins after loadOntology: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins after loadOntology: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] document.builtins after loadOntology: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] document.builtins after loadOntology: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] Parsed rules: []
[N3LogicReasoner][DEBUG] Parsed rules: []
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterLoadOntology [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        }
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        }
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterLoadOntology [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        }
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        }
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterLoadOntology args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        }
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        }
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterLoadOntology args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        }
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        }
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterLoadOntology",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "foo"
          }
        },
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "bar"
          }
        }
      ],
      "rules": [],
      "builtins": [
        {
          "uri": "http://example.org/custom#isFoo",
          "arity": 1,
          "description": "Returns true if the subject is the literal \"foo\""
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterLoadOntology",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "foo"
          }
        },
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "bar"
          }
        }
      ],
      "rules": [],
      "builtins": [
        {
          "uri": "http://example.org/custom#isFoo",
          "arity": 1,
          "description": "Returns true if the subject is the literal \"foo\""
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterLoadOntology
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterLoadOntology
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterLoadOntology
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterLoadOntology
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology finished
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology finished
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason() called
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason() called
[N3LogicReasoner][DEBUG] [REASONER] Starting reason() method. Current builtins: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [REASONER] Starting reason() method. Current builtins: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: merging builtins [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: merging builtins [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
] Resulting merged builtins: [
  {
    "uri": "http://example.org/custom#isFoo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
] Resulting merged builtins: [
  {
    "uri": "http://example.org/custom#isFoo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: document.builtins after merge [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: document.builtins after merge [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before reasoning: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before reasoning: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins before reasoning: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins before reasoning: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] Merged builtins for reasoning: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] Merged builtins for reasoning: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] Starting reasoning {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      },
      "_id": 2,
      "_provenance": "asserted"
    }
  ],
  "rules": []
}
[N3LogicReasoner][DEBUG] Starting reasoning {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      },
      "_id": 2,
      "_provenance": "asserted"
    }
  ],
  "rules": []
}
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: beforeReason [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        },
        "_id": 2,
        "_provenance": "asserted"
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: beforeReason [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        },
        "_id": 2,
        "_provenance": "asserted"
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: beforeReason args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        },
        "_id": 2,
        "_provenance": "asserted"
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: beforeReason args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        },
        "_id": 2,
        "_provenance": "asserted"
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "beforeReason",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "foo"
          },
          "_id": 1,
          "_provenance": "asserted"
        },
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "bar"
          },
          "_id": 2,
          "_provenance": "asserted"
        }
      ],
      "rules": [],
      "builtins": [
        {
          "uri": "http://example.org/custom#isFoo",
          "arity": 1,
          "description": "Returns true if the subject is the literal \"foo\""
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "beforeReason",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "foo"
          },
          "_id": 1,
          "_provenance": "asserted"
        },
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "bar"
          },
          "_id": 2,
          "_provenance": "asserted"
        }
      ],
      "rules": [],
      "builtins": [
        {
          "uri": "http://example.org/custom#isFoo",
          "arity": 1,
          "description": "Returns true if the subject is the literal \"foo\""
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for beforeReason
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook beforeReason
[N3LogicReasoner][DEBUG] Initial working triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] Initial working triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "foo"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "foo"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "foo"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "foo"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <b> "foo" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <b> "foo" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <b> "foo" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <b> "foo" .
[N3LogicReasoner][DEBUG] Adding initial triple to inferred set: <a> <b> "foo" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "foo"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][DEBUG] Adding initial triple to inferred set: <a> <b> "foo" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "foo"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "bar"
  },
  "_id": 2,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "bar"
  },
  "_id": 2,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "bar"
  },
  "_id": 2,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "bar"
  },
  "_id": 2,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <b> "bar" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <b> "bar" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <b> "bar" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <b> "bar" .
[N3LogicReasoner][DEBUG] Adding initial triple to inferred set: <a> <b> "bar" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "bar"
  },
  "_id": 2,
  "_provenance": "asserted"
}
[N3LogicReasoner][DEBUG] Adding initial triple to inferred set: <a> <b> "bar" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "bar"
  },
  "_id": 2,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Reasoning iteration 1 START
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Reasoning iteration 1 START
[N3LogicReasoner][DEBUG] 
=== Reasoning iteration 1 START ===
[N3LogicReasoner][DEBUG] 
=== Reasoning iteration 1 START ===
[N3LogicReasoner][DEBUG] Current triple store at start of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] Current triple store at start of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] New triples inferred in iteration 1: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] New triples inferred in iteration 1: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] New triples inferred in iteration 1: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] New triples inferred in iteration 1: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Rules fired in iteration 1: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Rules fired in iteration 1: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Rules fired in iteration 1: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Rules fired in iteration 1: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] === Reasoning iteration 1 END. changed=false ===
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] === Reasoning iteration 1 END. changed=false ===
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] === Reasoning iteration 1 END. changed=false ===

[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] === Reasoning iteration 1 END. changed=false ===

[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterReason [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      },
      "_id": 2,
      "_provenance": "asserted"
    }
  ]
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterReason [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      },
      "_id": 2,
      "_provenance": "asserted"
    }
  ]
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterReason args: [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      },
      "_id": 2,
      "_provenance": "asserted"
    }
  ]
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterReason args: [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      },
      "_id": 2,
      "_provenance": "asserted"
    }
  ]
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterReason",
  "args": [
    [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        },
        "_id": 2,
        "_provenance": "asserted"
      }
    ]
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterReason",
  "args": [
    [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        },
        "_id": 2,
        "_provenance": "asserted"
      }
    ]
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterReason
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook afterReason
[N3LogicReasoner][DEBUG] Reasoning complete. Inferred triples: [
  "<a> <b> \"foo\" .",
  "<a> <b> \"bar\" ."
]
[N3LogicReasoner][DEBUG] Reasoning complete. Inferred triples: [
  "<a> <b> \"foo\" .",
  "<a> <b> \"bar\" ."
]
[N3LogicReasoner][TRACE] stringToTriple input: <a> <b> "foo" .
[N3LogicReasoner][TRACE] stringToTriple input: <a> <b> "foo" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <b> "foo" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <b> "foo" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<b>",
  "object": "\"foo\""
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<b>",
  "object": "\"foo\""
}
[N3LogicReasoner][TRACE] stringToTriple input: <a> <b> "bar" .
[N3LogicReasoner][TRACE] stringToTriple input: <a> <b> "bar" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <b> "bar" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <b> "bar" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<b>",
  "object": "\"bar\""
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<b>",
  "object": "\"bar\""
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: finished, returning result
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: finished, returning result
[TEST reasoner custom builtins] All inferred triples: [
  "<a> <b> \"foo\" .",
  "<a> <b> \"bar\" ."
]
[DEBUG] result.triples: [
  "<a> <b> \"foo\" .",
  "<a> <b> \"bar\" ."
]
[DEBUG] inferredTriple: 
[N3LogicReasoner][TRACE] [N3LogicReasoner] setDebug called: false
[N3LogicReasoner][TRACE] [N3LogicReasoner] setDebug called: false
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] setDebug finished: false
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] setDebug finished: false
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin called: {
  "uri": "http://example.org/custom#isFoo",
  "arity": 1,
  "description": "Returns true if the subject is the literal \"foo\""
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin called: {
  "uri": "http://example.org/custom#isFoo",
  "arity": 1,
  "description": "Returns true if the subject is the literal \"foo\""
}
[N3LogicReasoner][DEBUG] Reasoner: All triples at start: []
[N3LogicReasoner][DEBUG] Reasoner: All triples at start: []
[N3LogicReasoner][DEBUG] Reasoner: All rules at start: []
[N3LogicReasoner][DEBUG] Reasoner: All rules at start: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Builtins before registerBuiltin: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Builtins before registerBuiltin: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin: customBuiltins after push [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin: customBuiltins after push [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][PATCHED] customBuiltins after push: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][PATCHED] customBuiltins after push: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin: merging builtins [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin: merging builtins [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
] Resulting merged builtins: [
  {
    "uri": "http://example.org/custom#isFoo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
] Resulting merged builtins: [
  {
    "uri": "http://example.org/custom#isFoo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin: document.builtins after merge [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin: document.builtins after merge [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][PATCHED] Builtins after registerBuiltin: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][PATCHED] Builtins after registerBuiltin: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][PATCHED] customBuiltins after registerBuiltin: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][PATCHED] customBuiltins after registerBuiltin: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin finished
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] registerBuiltin finished
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology called: {
  "format": "n3",
  "data": "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } ."
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology called: {
  "format": "n3",
  "data": "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } ."
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before loadOntology: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before loadOntology: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] Loading ontology {
  "format": "n3",
  "data": "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } ."
}
[N3LogicReasoner][DEBUG] Loading ontology {
  "format": "n3",
  "data": "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } ."
}
[N3LogicReasoner][TRACE] [N3LogicParser] parse called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } .
[N3LogicReasoner][TRACE] [N3LogicParser] parse called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } .
[N3LogicReasoner][TRACE] [N3LogicParser] Parsing input <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } .
[N3LogicReasoner][TRACE] [N3LogicParser] Parsing input <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } .
[N3LogicParser] Parsing input <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom#isFoo> ?x } => { <a> <c> ?x } .
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Initializing parse loop
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Initializing parse loop
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom false
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicParser] [TRACE][parseTriples] input: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicParser] [TRACE][splitTriples] input: "<a> <b> \"foo\" . <a> <b> \"bar\" . { <a> <b> ?x . ?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '"', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '"', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[8] = '"', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = 'f', buf='<a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = 'f', buf='<a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[9] = 'f', buf='<a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[10] = 'o', buf='<a> <b> "f', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[10] = 'o', buf='<a> <b> "f', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[10] = 'o', buf='<a> <b> "f', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[11] = 'o', buf='<a> <b> "fo', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[11] = 'o', buf='<a> <b> "fo', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[11] = 'o', buf='<a> <b> "fo', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[12] = '"', buf='<a> <b> "foo', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[12] = '"', buf='<a> <b> "foo', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[12] = '"', buf='<a> <b> "foo', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[13] = ' ', buf='<a> <b> "foo"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[13] = ' ', buf='<a> <b> "foo"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[13] = ' ', buf='<a> <b> "foo"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[14] = '.', buf='<a> <b> "foo" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[14] = '.', buf='<a> <b> "foo" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[14] = '.', buf='<a> <b> "foo" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: "<a> <b> \"foo\" "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: "<a> <b> \"foo\" "
[N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: "<a> <b> \"foo\" "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"foo\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"foo\""
[N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"foo\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[15] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[15] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[15] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[16] = '<', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[16] = '<', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[16] = '<', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[17] = 'a', buf=' <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[17] = 'a', buf=' <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[17] = 'a', buf=' <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[18] = '>', buf=' <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[18] = '>', buf=' <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[18] = '>', buf=' <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[19] = ' ', buf=' <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[19] = ' ', buf=' <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[19] = ' ', buf=' <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[20] = '<', buf=' <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[20] = '<', buf=' <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[20] = '<', buf=' <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[21] = 'b', buf=' <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[21] = 'b', buf=' <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[21] = 'b', buf=' <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[22] = '>', buf=' <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[22] = '>', buf=' <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[22] = '>', buf=' <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[23] = ' ', buf=' <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[23] = ' ', buf=' <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[23] = ' ', buf=' <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[24] = '"', buf=' <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[24] = '"', buf=' <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[24] = '"', buf=' <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[25] = 'b', buf=' <a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[25] = 'b', buf=' <a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[25] = 'b', buf=' <a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[26] = 'a', buf=' <a> <b> "b', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[26] = 'a', buf=' <a> <b> "b', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[26] = 'a', buf=' <a> <b> "b', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[27] = 'r', buf=' <a> <b> "ba', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[27] = 'r', buf=' <a> <b> "ba', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[27] = 'r', buf=' <a> <b> "ba', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[28] = '"', buf=' <a> <b> "bar', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[28] = '"', buf=' <a> <b> "bar', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[28] = '"', buf=' <a> <b> "bar', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[29] = ' ', buf=' <a> <b> "bar"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[29] = ' ', buf=' <a> <b> "bar"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[29] = ' ', buf=' <a> <b> "bar"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[30] = '.', buf=' <a> <b> "bar" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[30] = '.', buf=' <a> <b> "bar" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[30] = '.', buf=' <a> <b> "bar" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " <a> <b> \"bar\" "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " <a> <b> \"bar\" "
[N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " <a> <b> \"bar\" "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"bar\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"bar\""
[N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"bar\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[31] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[31] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[31] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[32] = '{', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[32] = '{', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[32] = '{', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[33] = ' ', buf=' {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[33] = ' ', buf=' {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[33] = ' ', buf=' {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[34] = '<', buf=' { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[34] = '<', buf=' { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[34] = '<', buf=' { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[35] = 'a', buf=' { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[35] = 'a', buf=' { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[35] = 'a', buf=' { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[36] = '>', buf=' { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[36] = '>', buf=' { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[36] = '>', buf=' { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[37] = ' ', buf=' { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[37] = ' ', buf=' { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[37] = ' ', buf=' { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[38] = '<', buf=' { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[38] = '<', buf=' { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[38] = '<', buf=' { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[39] = 'b', buf=' { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[39] = 'b', buf=' { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[39] = 'b', buf=' { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[40] = '>', buf=' { <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[40] = '>', buf=' { <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[40] = '>', buf=' { <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[41] = ' ', buf=' { <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[41] = ' ', buf=' { <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[41] = ' ', buf=' { <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[42] = '?', buf=' { <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[42] = '?', buf=' { <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[42] = '?', buf=' { <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[43] = 'x', buf=' { <a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[43] = 'x', buf=' { <a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[43] = 'x', buf=' { <a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[44] = ' ', buf=' { <a> <b> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[44] = ' ', buf=' { <a> <b> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[44] = ' ', buf=' { <a> <b> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[45] = '.', buf=' { <a> <b> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[45] = '.', buf=' { <a> <b> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[45] = '.', buf=' { <a> <b> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " { <a> <b> ?x "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " { <a> <b> ?x "
[N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " { <a> <b> ?x "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "{ <a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "{ <a> <b> ?x"
[N3LogicParser] [TRACE][splitTriples] Found triple statement: "{ <a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[46] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[46] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[46] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[47] = '?', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[47] = '?', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[47] = '?', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[48] = 'x', buf=' ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[48] = 'x', buf=' ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[48] = 'x', buf=' ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[49] = ' ', buf=' ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[49] = ' ', buf=' ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[49] = ' ', buf=' ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[50] = '<', buf=' ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[50] = '<', buf=' ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[50] = '<', buf=' ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[51] = 'h', buf=' ?x <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[51] = 'h', buf=' ?x <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[51] = 'h', buf=' ?x <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[52] = 't', buf=' ?x <h', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[52] = 't', buf=' ?x <h', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[52] = 't', buf=' ?x <h', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[53] = 't', buf=' ?x <ht', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[53] = 't', buf=' ?x <ht', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[53] = 't', buf=' ?x <ht', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[54] = 'p', buf=' ?x <htt', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[54] = 'p', buf=' ?x <htt', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[54] = 'p', buf=' ?x <htt', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[55] = ':', buf=' ?x <http', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[55] = ':', buf=' ?x <http', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[55] = ':', buf=' ?x <http', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[56] = '/', buf=' ?x <http:', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[56] = '/', buf=' ?x <http:', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[56] = '/', buf=' ?x <http:', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[57] = '/', buf=' ?x <http:/', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[57] = '/', buf=' ?x <http:/', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[57] = '/', buf=' ?x <http:/', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[58] = 'e', buf=' ?x <http://', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[58] = 'e', buf=' ?x <http://', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[58] = 'e', buf=' ?x <http://', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[59] = 'x', buf=' ?x <http://e', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[59] = 'x', buf=' ?x <http://e', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[59] = 'x', buf=' ?x <http://e', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[60] = 'a', buf=' ?x <http://ex', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[60] = 'a', buf=' ?x <http://ex', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[60] = 'a', buf=' ?x <http://ex', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[61] = 'm', buf=' ?x <http://exa', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[61] = 'm', buf=' ?x <http://exa', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[61] = 'm', buf=' ?x <http://exa', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[62] = 'p', buf=' ?x <http://exam', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[62] = 'p', buf=' ?x <http://exam', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[62] = 'p', buf=' ?x <http://exam', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[63] = 'l', buf=' ?x <http://examp', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[63] = 'l', buf=' ?x <http://examp', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[63] = 'l', buf=' ?x <http://examp', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[64] = 'e', buf=' ?x <http://exampl', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[64] = 'e', buf=' ?x <http://exampl', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[64] = 'e', buf=' ?x <http://exampl', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[65] = '.', buf=' ?x <http://example', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[65] = '.', buf=' ?x <http://example', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[65] = '.', buf=' ?x <http://example', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[66] = 'o', buf=' ?x <http://example.', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[66] = 'o', buf=' ?x <http://example.', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[66] = 'o', buf=' ?x <http://example.', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[67] = 'r', buf=' ?x <http://example.o', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[67] = 'r', buf=' ?x <http://example.o', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[67] = 'r', buf=' ?x <http://example.o', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[68] = 'g', buf=' ?x <http://example.or', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[68] = 'g', buf=' ?x <http://example.or', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[68] = 'g', buf=' ?x <http://example.or', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[69] = '/', buf=' ?x <http://example.org', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[69] = '/', buf=' ?x <http://example.org', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[69] = '/', buf=' ?x <http://example.org', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[70] = 'c', buf=' ?x <http://example.org/', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[70] = 'c', buf=' ?x <http://example.org/', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[70] = 'c', buf=' ?x <http://example.org/', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[71] = 'u', buf=' ?x <http://example.org/c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[71] = 'u', buf=' ?x <http://example.org/c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[71] = 'u', buf=' ?x <http://example.org/c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[72] = 's', buf=' ?x <http://example.org/cu', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[72] = 's', buf=' ?x <http://example.org/cu', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[72] = 's', buf=' ?x <http://example.org/cu', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[73] = 't', buf=' ?x <http://example.org/cus', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[73] = 't', buf=' ?x <http://example.org/cus', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[73] = 't', buf=' ?x <http://example.org/cus', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[74] = 'o', buf=' ?x <http://example.org/cust', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[74] = 'o', buf=' ?x <http://example.org/cust', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[74] = 'o', buf=' ?x <http://example.org/cust', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[75] = 'm', buf=' ?x <http://example.org/custo', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[75] = 'm', buf=' ?x <http://example.org/custo', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[75] = 'm', buf=' ?x <http://example.org/custo', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found final triple statement: "?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found final triple statement: "?x <http://example.org/custom"
[N3LogicParser] [TRACE][splitTriples] Found final triple statement: "?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> \"foo\"","<a> <b> \"bar\"","{ <a> <b> ?x","?x <http://example.org/custom"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> \"foo\"","<a> <b> \"bar\"","{ <a> <b> ?x","?x <http://example.org/custom"]
[N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> \"foo\"","<a> <b> \"bar\"","{ <a> <b> ?x","?x <http://example.org/custom"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> \"foo\"","<a> <b> \"bar\"","{ <a> <b> ?x","?x <http://example.org/custom"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> \"foo\"","<a> <b> \"bar\"","{ <a> <b> ?x","?x <http://example.org/custom"]
[N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> \"foo\"","<a> <b> \"bar\"","{ <a> <b> ?x","?x <http://example.org/custom"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"foo\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"foo\""
[N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"foo\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"foo\""]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"foo\""]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"foo\""]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "foo"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "foo"
[N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "foo"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: "foo"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: "foo"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"foo"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"foo"}}
[N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"foo"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"bar\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"bar\""
[N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"bar\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"bar\""]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"bar\""]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"bar\""]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "bar"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "bar"
[N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "bar"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: "bar"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: "bar"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"bar"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"bar"}}
[N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"bar"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "{ <a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "{ <a> <b> ?x"
[N3LogicParser] [TRACE][parseTriples] parsing statement: "{ <a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["{","<a>","<b>","?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["{","<a>","<b>","?x"]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["{","<a>","<b>","?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 4 [
  "{",
  "<a>",
  "<b>",
  "?x"
]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 4 [
  "{",
  "<a>",
  "<b>",
  "?x"
]
[N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 4 [
  "{",
  "<a>",
  "<b>",
  "?x"
]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <b>
[N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <b>
[N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "?x <http://example.org/custom"
[N3LogicParser] [TRACE][parseTriples] parsing statement: "?x <http://example.org/custom"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["?x","<http://example.org/custom"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["?x","<http://example.org/custom"]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["?x","<http://example.org/custom"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 2 [
  "?x",
  "<http://example.org/custom"
]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 2 [
  "?x",
  "<http://example.org/custom"
]
[N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 2 [
  "?x",
  "<http://example.org/custom"
]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"foo"}},{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"bar"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"foo"}},{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"bar"}}]
[N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"foo"}},{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"bar"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
]
[N3LogicParser] N3LogicParser: Parsed triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] parseRules called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom
[N3LogicReasoner][TRACE] [N3LogicParser] parseRules called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom
[N3LogicReasoner][TRACE] [RuleExtractor] extractRules called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom
[N3LogicReasoner][TRACE] [RuleExtractor] extractRules called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed rules: []
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed rules: []
[N3LogicParser] N3LogicParser: Parsed rules: []
[N3LogicReasoner][TRACE] [N3LogicParser] parseBuiltins called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom
[N3LogicReasoner][TRACE] [N3LogicParser] parseBuiltins called: <a> <b> "foo" . <a> <b> "bar" . { <a> <b> ?x . ?x <http://example.org/custom
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed builtins: []
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed builtins: []
[N3LogicParser] N3LogicParser: Parsed builtins: []
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Parsing loop complete, triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
] rules: []
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Parsing loop complete, triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
] rules: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: parsedDoc {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      }
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      }
    }
  ],
  "rules": [],
  "builtins": []
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: parsedDoc {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      }
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      }
    }
  ],
  "rules": [],
  "builtins": []
}
[N3LogicReasoner][DEBUG] N3LogicReasoner: Parsed rules after parsing: []
[N3LogicReasoner][DEBUG] N3LogicReasoner: Parsed rules after parsing: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] Parsed triples after parsing: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] Parsed triples after parsing: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: merging builtins [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: merging builtins [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
] Resulting merged builtins: [
  {
    "uri": "http://example.org/custom#isFoo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
] Resulting merged builtins: [
  {
    "uri": "http://example.org/custom#isFoo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: document.builtins after merge [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: document.builtins after merge [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins after loadOntology: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins after loadOntology: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] document.builtins after loadOntology: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] document.builtins after loadOntology: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] Parsed rules: []
[N3LogicReasoner][DEBUG] Parsed rules: []
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterLoadOntology [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        }
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        }
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterLoadOntology [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        }
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        }
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterLoadOntology args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        }
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        }
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterLoadOntology args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        }
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        }
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterLoadOntology",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "foo"
          }
        },
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "bar"
          }
        }
      ],
      "rules": [],
      "builtins": [
        {
          "uri": "http://example.org/custom#isFoo",
          "arity": 1,
          "description": "Returns true if the subject is the literal \"foo\""
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterLoadOntology",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "foo"
          }
        },
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "bar"
          }
        }
      ],
      "rules": [],
      "builtins": [
        {
          "uri": "http://example.org/custom#isFoo",
          "arity": 1,
          "description": "Returns true if the subject is the literal \"foo\""
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterLoadOntology
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterLoadOntology
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterLoadOntology
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterLoadOntology
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology finished
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology finished
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason() called
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason() called
[N3LogicReasoner][DEBUG] [REASONER] Starting reason() method. Current builtins: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [REASONER] Starting reason() method. Current builtins: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: merging builtins [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: merging builtins [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
] Resulting merged builtins: [
  {
    "uri": "http://example.org/custom#isFoo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  }
] Resulting merged builtins: [
  {
    "uri": "http://example.org/custom#isFoo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: document.builtins after merge [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: document.builtins after merge [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before reasoning: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before reasoning: [
  "http://example.org/custom#isFoo"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins before reasoning: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins before reasoning: [
  "http://example.org/custom#isFoo",
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] Merged builtins for reasoning: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] Merged builtins for reasoning: [
  {
    "uri": "http://example.org/custom#isFoo",
    "arity": 1,
    "description": "Returns true if the subject is the literal \"foo\""
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] Starting reasoning {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      },
      "_id": 2,
      "_provenance": "asserted"
    }
  ],
  "rules": []
}
[N3LogicReasoner][DEBUG] Starting reasoning {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      },
      "_id": 2,
      "_provenance": "asserted"
    }
  ],
  "rules": []
}
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: beforeReason [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        },
        "_id": 2,
        "_provenance": "asserted"
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: beforeReason [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        },
        "_id": 2,
        "_provenance": "asserted"
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: beforeReason args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        },
        "_id": 2,
        "_provenance": "asserted"
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: beforeReason args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        },
        "_id": 2,
        "_provenance": "asserted"
      }
    ],
    "rules": [],
    "builtins": [
      {
        "uri": "http://example.org/custom#isFoo",
        "arity": 1,
        "description": "Returns true if the subject is the literal \"foo\""
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "beforeReason",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "foo"
          },
          "_id": 1,
          "_provenance": "asserted"
        },
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "bar"
          },
          "_id": 2,
          "_provenance": "asserted"
        }
      ],
      "rules": [],
      "builtins": [
        {
          "uri": "http://example.org/custom#isFoo",
          "arity": 1,
          "description": "Returns true if the subject is the literal \"foo\""
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "beforeReason",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "foo"
          },
          "_id": 1,
          "_provenance": "asserted"
        },
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "bar"
          },
          "_id": 2,
          "_provenance": "asserted"
        }
      ],
      "rules": [],
      "builtins": [
        {
          "uri": "http://example.org/custom#isFoo",
          "arity": 1,
          "description": "Returns true if the subject is the literal \"foo\""
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for beforeReason
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook beforeReason
[N3LogicReasoner][DEBUG] Initial working triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] Initial working triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "foo"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "foo"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "foo"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "foo"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <b> "foo" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <b> "foo" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <b> "foo" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <b> "foo" .
[N3LogicReasoner][DEBUG] Adding initial triple to inferred set: <a> <b> "foo" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "foo"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][DEBUG] Adding initial triple to inferred set: <a> <b> "foo" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "foo"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "bar"
  },
  "_id": 2,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "bar"
  },
  "_id": 2,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "bar"
  },
  "_id": 2,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "bar"
  },
  "_id": 2,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <b> "bar" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <b> "bar" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <b> "bar" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <b> "bar" .
[N3LogicReasoner][DEBUG] Adding initial triple to inferred set: <a> <b> "bar" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "bar"
  },
  "_id": 2,
  "_provenance": "asserted"
}
[N3LogicReasoner][DEBUG] Adding initial triple to inferred set: <a> <b> "bar" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "bar"
  },
  "_id": 2,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Reasoning iteration 1 START
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Reasoning iteration 1 START
[N3LogicReasoner][DEBUG] 
=== Reasoning iteration 1 START ===
[N3LogicReasoner][DEBUG] 
=== Reasoning iteration 1 START ===
[N3LogicReasoner][DEBUG] Current triple store at start of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] Current triple store at start of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] New triples inferred in iteration 1: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] New triples inferred in iteration 1: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] New triples inferred in iteration 1: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] New triples inferred in iteration 1: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Rules fired in iteration 1: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Rules fired in iteration 1: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Rules fired in iteration 1: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Rules fired in iteration 1: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "foo"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "bar"
    },
    "_id": 2,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] === Reasoning iteration 1 END. changed=false ===
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] === Reasoning iteration 1 END. changed=false ===
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] === Reasoning iteration 1 END. changed=false ===

[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] === Reasoning iteration 1 END. changed=false ===

[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterReason [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      },
      "_id": 2,
      "_provenance": "asserted"
    }
  ]
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterReason [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      },
      "_id": 2,
      "_provenance": "asserted"
    }
  ]
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterReason args: [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      },
      "_id": 2,
      "_provenance": "asserted"
    }
  ]
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterReason args: [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "foo"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "bar"
      },
      "_id": 2,
      "_provenance": "asserted"
    }
  ]
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterReason",
  "args": [
    [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        },
        "_id": 2,
        "_provenance": "asserted"
      }
    ]
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterReason",
  "args": [
    [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "foo"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "bar"
        },
        "_id": 2,
        "_provenance": "asserted"
      }
    ]
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterReason
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook afterReason
[N3LogicReasoner][DEBUG] Reasoning complete. Inferred triples: [
  "<a> <b> \"foo\" .",
  "<a> <b> \"bar\" ."
]
[N3LogicReasoner][DEBUG] Reasoning complete. Inferred triples: [
  "<a> <b> \"foo\" .",
  "<a> <b> \"bar\" ."
]
[N3LogicReasoner][TRACE] stringToTriple input: <a> <b> "foo" .
[N3LogicReasoner][TRACE] stringToTriple input: <a> <b> "foo" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <b> "foo" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <b> "foo" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<b>",
  "object": "\"foo\""
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<b>",
  "object": "\"foo\""
}
[N3LogicReasoner][TRACE] stringToTriple input: <a> <b> "bar" .
[N3LogicReasoner][TRACE] stringToTriple input: <a> <b> "bar" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <b> "bar" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <b> "bar" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<b>",
  "object": "\"bar\""
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<b>",
  "object": "\"bar\""
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: finished, returning result
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: finished, returning result
[DIAG] All triples: [
  "<a> <b> \"foo\" .",
  "<a> <b> \"bar\" ."
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] setDebug called: true
[N3LogicReasoner][TRACE] [N3LogicReasoner] setDebug called: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] setDebug finished: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] setDebug finished: true
[N3LogicReasoner][TRACE] [N3LogicReasoner] on(hookName) called: afterRuleApplied callback: () => {
            hookFired = true;
            // Defer assertion to next tick to ensure hook fires
            setTimeout(() => {
                expect(hookFired).toBe(true);
                done();
            }, 0);
        }
[N3LogicReasoner][TRACE] [N3LogicReasoner] on(hookName) called: afterRuleApplied callback: () => {
            hookFired = true;
            // Defer assertion to next tick to ensure hook fires
            setTimeout(() => {
                expect(hookFired).toBe(true);
                done();
            }, 0);
        }
[N3LogicReasoner][TRACE] [hooks][TRACE] on/registerHook called: {
  "hookName": "afterRuleApplied"
}
[N3LogicReasoner][TRACE] [hooks][TRACE] on/registerHook called: {
  "hookName": "afterRuleApplied"
}
[N3LogicReasoner][TRACE] [hooks][TRACE] on/registerHook finished: {
  "hookName": "afterRuleApplied",
  "count": 1
}
[N3LogicReasoner][TRACE] [hooks][TRACE] on/registerHook finished: {
  "hookName": "afterRuleApplied",
  "count": 1
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology called: {
  "format": "n3",
  "data": "\n\t\t\t<a> <b> \"1\" .\n\t\t\t{ <a> <b> ?x } => { <a> <c> ?x } .\n\t\t"
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology called: {
  "format": "n3",
  "data": "\n\t\t\t<a> <b> \"1\" .\n\t\t\t{ <a> <b> ?x } => { <a> <c> ?x } .\n\t\t"
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before loadOntology: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before loadOntology: []
[N3LogicReasoner][DEBUG] Loading ontology {
  "format": "n3",
  "data": "\n\t\t\t<a> <b> \"1\" .\n\t\t\t{ <a> <b> ?x } => { <a> <c> ?x } .\n\t\t"
}
[N3LogicReasoner][DEBUG] Loading ontology {
  "format": "n3",
  "data": "\n\t\t\t<a> <b> \"1\" .\n\t\t\t{ <a> <b> ?x } => { <a> <c> ?x } .\n\t\t"
}
[N3LogicReasoner][TRACE] [N3LogicParser] parse called: 
			<a> <b> "1" .
			{ <a> <b> ?x } => { <a> <c> ?x } .
		
[N3LogicReasoner][TRACE] [N3LogicParser] parse called: 
			<a> <b> "1" .
			{ <a> <b> ?x } => { <a> <c> ?x } .
		
[N3LogicReasoner][TRACE] [N3LogicParser] Parsing input 
			<a> <b> "1" .
			{ <a> <b> ?x } => { <a> <c> ?x } .
		
[N3LogicReasoner][TRACE] [N3LogicParser] Parsing input 
			<a> <b> "1" .
			{ <a> <b> ?x } => { <a> <c> ?x } .
		
[N3LogicParser] Parsing input 
			<a> <b> "1" .
			{ <a> <b> ?x } => { <a> <c> ?x } .
		
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Initializing parse loop
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Initializing parse loop
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <b> "1" . { <a> <b> ?x } => { <a> <c> ?x } . false
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <b> "1" . { <a> <b> ?x } => { <a> <c> ?x } . false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicParser] [TRACE][parseTriples] input: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicParser] [TRACE][splitTriples] input: "<a> <b> \"1\" . { <a> <b> ?x } => { <a> <c> ?x } ."
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '"', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '"', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[8] = '"', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = '1', buf='<a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = '1', buf='<a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[9] = '1', buf='<a> <b> "', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[10] = '"', buf='<a> <b> "1', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[10] = '"', buf='<a> <b> "1', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicParser] [TRACE][splitTriples] char[10] = '"', buf='<a> <b> "1', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[11] = ' ', buf='<a> <b> "1"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[11] = ' ', buf='<a> <b> "1"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[11] = ' ', buf='<a> <b> "1"', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[12] = '.', buf='<a> <b> "1" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[12] = '.', buf='<a> <b> "1" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[12] = '.', buf='<a> <b> "1" ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: "<a> <b> \"1\" "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: "<a> <b> \"1\" "
[N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: "<a> <b> \"1\" "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"1\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"1\""
[N3LogicParser] [TRACE][splitTriples] Found triple statement: "<a> <b> \"1\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[13] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[13] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[13] = ' ', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[14] = '{', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[14] = '{', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[14] = '{', buf=' ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[15] = ' ', buf=' {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[15] = ' ', buf=' {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[15] = ' ', buf=' {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[16] = '<', buf=' { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[16] = '<', buf=' { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[16] = '<', buf=' { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[17] = 'a', buf=' { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[17] = 'a', buf=' { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[17] = 'a', buf=' { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[18] = '>', buf=' { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[18] = '>', buf=' { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[18] = '>', buf=' { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[19] = ' ', buf=' { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[19] = ' ', buf=' { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[19] = ' ', buf=' { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[20] = '<', buf=' { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[20] = '<', buf=' { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[20] = '<', buf=' { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[21] = 'b', buf=' { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[21] = 'b', buf=' { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[21] = 'b', buf=' { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[22] = '>', buf=' { <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[22] = '>', buf=' { <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[22] = '>', buf=' { <a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[23] = ' ', buf=' { <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[23] = ' ', buf=' { <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[23] = ' ', buf=' { <a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[24] = '?', buf=' { <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[24] = '?', buf=' { <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[24] = '?', buf=' { <a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[25] = 'x', buf=' { <a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[25] = 'x', buf=' { <a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[25] = 'x', buf=' { <a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[26] = ' ', buf=' { <a> <b> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[26] = ' ', buf=' { <a> <b> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[26] = ' ', buf=' { <a> <b> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[27] = '}', buf=' { <a> <b> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[27] = '}', buf=' { <a> <b> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[27] = '}', buf=' { <a> <b> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[28] = ' ', buf=' { <a> <b> ?x }', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[28] = ' ', buf=' { <a> <b> ?x }', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[28] = ' ', buf=' { <a> <b> ?x }', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[29] = '=', buf=' { <a> <b> ?x } ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[29] = '=', buf=' { <a> <b> ?x } ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[29] = '=', buf=' { <a> <b> ?x } ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[30] = '>', buf=' { <a> <b> ?x } =', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[30] = '>', buf=' { <a> <b> ?x } =', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[30] = '>', buf=' { <a> <b> ?x } =', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[31] = ' ', buf=' { <a> <b> ?x } =>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[31] = ' ', buf=' { <a> <b> ?x } =>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[31] = ' ', buf=' { <a> <b> ?x } =>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[32] = '{', buf=' { <a> <b> ?x } => ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[32] = '{', buf=' { <a> <b> ?x } => ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[32] = '{', buf=' { <a> <b> ?x } => ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[33] = ' ', buf=' { <a> <b> ?x } => {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[33] = ' ', buf=' { <a> <b> ?x } => {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[33] = ' ', buf=' { <a> <b> ?x } => {', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[34] = '<', buf=' { <a> <b> ?x } => { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[34] = '<', buf=' { <a> <b> ?x } => { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[34] = '<', buf=' { <a> <b> ?x } => { ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[35] = 'a', buf=' { <a> <b> ?x } => { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[35] = 'a', buf=' { <a> <b> ?x } => { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[35] = 'a', buf=' { <a> <b> ?x } => { <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[36] = '>', buf=' { <a> <b> ?x } => { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[36] = '>', buf=' { <a> <b> ?x } => { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[36] = '>', buf=' { <a> <b> ?x } => { <a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[37] = ' ', buf=' { <a> <b> ?x } => { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[37] = ' ', buf=' { <a> <b> ?x } => { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[37] = ' ', buf=' { <a> <b> ?x } => { <a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[38] = '<', buf=' { <a> <b> ?x } => { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[38] = '<', buf=' { <a> <b> ?x } => { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[38] = '<', buf=' { <a> <b> ?x } => { <a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[39] = 'c', buf=' { <a> <b> ?x } => { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[39] = 'c', buf=' { <a> <b> ?x } => { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[39] = 'c', buf=' { <a> <b> ?x } => { <a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[40] = '>', buf=' { <a> <b> ?x } => { <a> <c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[40] = '>', buf=' { <a> <b> ?x } => { <a> <c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[40] = '>', buf=' { <a> <b> ?x } => { <a> <c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[41] = ' ', buf=' { <a> <b> ?x } => { <a> <c>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[41] = ' ', buf=' { <a> <b> ?x } => { <a> <c>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[41] = ' ', buf=' { <a> <b> ?x } => { <a> <c>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[42] = '?', buf=' { <a> <b> ?x } => { <a> <c> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[42] = '?', buf=' { <a> <b> ?x } => { <a> <c> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[42] = '?', buf=' { <a> <b> ?x } => { <a> <c> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[43] = 'x', buf=' { <a> <b> ?x } => { <a> <c> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[43] = 'x', buf=' { <a> <b> ?x } => { <a> <c> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[43] = 'x', buf=' { <a> <b> ?x } => { <a> <c> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[44] = ' ', buf=' { <a> <b> ?x } => { <a> <c> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[44] = ' ', buf=' { <a> <b> ?x } => { <a> <c> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[44] = ' ', buf=' { <a> <b> ?x } => { <a> <c> ?x', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[45] = '}', buf=' { <a> <b> ?x } => { <a> <c> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[45] = '}', buf=' { <a> <b> ?x } => { <a> <c> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[45] = '}', buf=' { <a> <b> ?x } => { <a> <c> ?x ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[46] = ' ', buf=' { <a> <b> ?x } => { <a> <c> ?x }', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[46] = ' ', buf=' { <a> <b> ?x } => { <a> <c> ?x }', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[46] = ' ', buf=' { <a> <b> ?x } => { <a> <c> ?x }', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[47] = '.', buf=' { <a> <b> ?x } => { <a> <c> ?x } ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[47] = '.', buf=' { <a> <b> ?x } => { <a> <c> ?x } ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[47] = '.', buf=' { <a> <b> ?x } => { <a> <c> ?x } ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " { <a> <b> ?x } => { <a> <c> ?x } "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " { <a> <b> ?x } => { <a> <c> ?x } "
[N3LogicParser] [TRACE][splitTriples] splitting at char '.', buf before split: " { <a> <b> ?x } => { <a> <c> ?x } "
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "{ <a> <b> ?x } => { <a> <c> ?x }"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found triple statement: "{ <a> <b> ?x } => { <a> <c> ?x }"
[N3LogicParser] [TRACE][splitTriples] Found triple statement: "{ <a> <b> ?x } => { <a> <c> ?x }"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Skipping final empty/whitespace-only buffer: ""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Skipping final empty/whitespace-only buffer: ""
[N3LogicParser] [TRACE][splitTriples] Skipping final empty/whitespace-only buffer: ""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> \"1\"","{ <a> <b> ?x } => { <a> <c> ?x }"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> \"1\"","{ <a> <b> ?x } => { <a> <c> ?x }"]
[N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> \"1\"","{ <a> <b> ?x } => { <a> <c> ?x }"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> \"1\"","{ <a> <b> ?x } => { <a> <c> ?x }"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> \"1\"","{ <a> <b> ?x } => { <a> <c> ?x }"]
[N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> \"1\"","{ <a> <b> ?x } => { <a> <c> ?x }"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"1\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"1\""
[N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> \"1\""
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"1\""]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"1\""]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","\"1\""]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "1"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "1"
[N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> "1"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: "1"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: "1"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"}}
[N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "{ <a> <b> ?x } => { <a> <c> ?x }"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "{ <a> <b> ?x } => { <a> <c> ?x }"
[N3LogicParser] [TRACE][parseTriples] parsing statement: "{ <a> <b> ?x } => { <a> <c> ?x }"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["{","<a>","<b>","?x","}","=>","{","<a>","<c>","?x","}"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["{","<a>","<b>","?x","}","=>","{","<a>","<c>","?x","}"]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["{","<a>","<b>","?x","}","=>","{","<a>","<c>","?x","}"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 11 [
  "{",
  "<a>",
  "<b>",
  "?x",
  "}",
  "=>",
  "{",
  "<a>",
  "<c>",
  "?x",
  "}"
]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 11 [
  "{",
  "<a>",
  "<b>",
  "?x",
  "}",
  "=>",
  "{",
  "<a>",
  "<c>",
  "?x",
  "}"
]
[N3LogicParser] [TRACE][parseTriples] WARNING: tokens.length not multiple of 3: 11 [
  "{",
  "<a>",
  "<b>",
  "?x",
  "}",
  "=>",
  "{",
  "<a>",
  "<c>",
  "?x",
  "}"
]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <b>
[N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <b>
[N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: ?x } =>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: ?x } =>
[N3LogicParser] [TRACE][parseTriples] Triple tokens: ?x } =>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: ?x } =>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: ?x } =>
[N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: ?x } =>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <c>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <c>
[N3LogicParser] [TRACE][parseTriples] Triple tokens: { <a> <c>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <c>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <c>
[N3LogicParser] [TRACE][parseTriples] Skipping invalid triple tokens: { <a> <c>
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"}}]
[N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicParser] N3LogicParser: Parsed triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] parseRules called: 
			<a> <b> "1" .
			{ <a> <b> ?x } => { <a> <c> ?x } .
		
[N3LogicReasoner][TRACE] [N3LogicParser] parseRules called: 
			<a> <b> "1" .
			{ <a> <b> ?x } => { <a> <c> ?x } .
		
[N3LogicReasoner][TRACE] [RuleExtractor] extractRules called: 
			<a> <b> "1" .
			{ <a> <b> ?x } => { <a> <c> ?x } .
		
[N3LogicReasoner][TRACE] [RuleExtractor] extractRules called: 
			<a> <b> "1" .
			{ <a> <b> ?x } => { <a> <c> ?x } .
		
[parseRules][DEBUG] antecedent string: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <b> ?x true
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <b> ?x true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <b> ?x"
[N3LogicParser] [TRACE][parseTriples] input: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> ?x"
[N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <b> ?x"
[N3LogicParser] [TRACE][splitTriples] input: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[5] = 'b', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <b', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <b>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '?', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '?', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[8] = '?', buf='<a> <b> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = 'x', buf='<a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = 'x', buf='<a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[9] = 'x', buf='<a> <b> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found final triple statement: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found final triple statement: "<a> <b> ?x"
[N3LogicParser] [TRACE][splitTriples] Found final triple statement: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> ?x"]
[N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <b> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> ?x"]
[N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <b> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> ?x"
[N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <b> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","?x"]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<b>","?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> ?x
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> ?x
[N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <b> ?x
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <b>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicParser] [parseTerm][RETURN IRI] <b> {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: ?x
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: ?x
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN VAR] ?x {"type":"Variable","value":"x"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN VAR] ?x {"type":"Variable","value":"x"}
[N3LogicParser] [parseTerm][RETURN VAR] ?x {"type":"Variable","value":"x"}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: b
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]
[N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <c> ?x true
[N3LogicReasoner][TRACE] [N3LogicParser] parseTriples called: <a> <c> ?x true
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] input: "<a> <c> ?x"
[N3LogicParser] [TRACE][parseTriples] input: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <c> ?x"
[N3LogicParser] [TRACE][parseTriples] Splitting rule block: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] input: "<a> <c> ?x"
[N3LogicParser] [TRACE][splitTriples] input: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[0] = '<', buf='', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[1] = 'a', buf='<', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[2] = '>', buf='<a', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[3] = ' ', buf='<a>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[4] = '<', buf='<a> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'c', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[5] = 'c', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[5] = 'c', buf='<a> <', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[6] = '>', buf='<a> <c', iriDepth=1, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <c>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <c>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[7] = ' ', buf='<a> <c>', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '?', buf='<a> <c> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[8] = '?', buf='<a> <c> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[8] = '?', buf='<a> <c> ', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = 'x', buf='<a> <c> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] char[9] = 'x', buf='<a> <c> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicParser] [TRACE][splitTriples] char[9] = 'x', buf='<a> <c> ?', iriDepth=0, parenDepth=0, bracketDepth=0, inQuote=false
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found final triple statement: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] Found final triple statement: "<a> <c> ?x"
[N3LogicParser] [TRACE][splitTriples] Found final triple statement: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <c> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <c> ?x"]
[N3LogicParser] [TRACE][splitTriples] output statements: ["<a> <c> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <c> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <c> ?x"]
[N3LogicParser] [TRACE][parseTriples] split statements: ["<a> <c> ?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <c> ?x"
[N3LogicParser] [TRACE][parseTriples] parsing statement: "<a> <c> ?x"
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<c>","?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<c>","?x"]
[N3LogicParser] [TRACE][parseTriples] Tokenized terms: ["<a>","<c>","?x"]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <c> ?x
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <c> ?x
[N3LogicParser] [TRACE][parseTriples] Triple tokens: <a> <c> ?x
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <a>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicParser] [parseTerm][RETURN IRI] <a> {"type":"IRI","value":"a"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <c>
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: <c>
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <c> {"type":"IRI","value":"c"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN IRI] <c> {"type":"IRI","value":"c"}
[N3LogicParser] [parseTerm][RETURN IRI] <c> {"type":"IRI","value":"c"}
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: ?x
[N3LogicReasoner][TRACE] [N3LogicParser] parseTerm called: ?x
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN VAR] ?x {"type":"Variable","value":"x"}
[N3LogicReasoner][TRACE] [N3LogicParser] [parseTerm][RETURN VAR] ?x {"type":"Variable","value":"x"}
[N3LogicParser] [parseTerm][RETURN VAR] ?x {"type":"Variable","value":"x"}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}
[N3LogicParser] [TRACE][parseTriples] Parsed triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: c
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: c
[N3LogicParser] [TRACE][parseTriples] Predicate type: IRI Predicate value: c
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]
[N3LogicParser] [TRACE][parseTriples] output triples: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]
[N3LogicReasoner][TRACE] [N3LogicParser] [parseRules][DEBUG][CUSTOM] Parsed rule antecedent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] [parseRules][DEBUG][CUSTOM] Parsed rule antecedent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicParser] [parseRules][DEBUG][CUSTOM] Parsed rule antecedent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] [parseRules][DEBUG][CUSTOM] Parsed rule consequent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] [parseRules][DEBUG][CUSTOM] Parsed rule consequent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicParser] [parseRules][DEBUG][CUSTOM] Parsed rule consequent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicParser] N3LogicParser: Parsed rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser] parseBuiltins called: 
			<a> <b> "1" .
			{ <a> <b> ?x } => { <a> <c> ?x } .
		
[N3LogicReasoner][TRACE] [N3LogicParser] parseBuiltins called: 
			<a> <b> "1" .
			{ <a> <b> ?x } => { <a> <c> ?x } .
		
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed builtins: []
[N3LogicReasoner][TRACE] [N3LogicParser] N3LogicParser: Parsed builtins: []
[N3LogicParser] N3LogicParser: Parsed builtins: []
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Parsing loop complete, triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
] rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicParser][TRACE] Parsing loop complete, triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
] rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: parsedDoc {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ],
  "rules": [
    {
      "type": "Rule",
      "antecedent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "b"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      },
      "consequent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "c"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      }
    }
  ],
  "builtins": []
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: parsedDoc {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ],
  "rules": [
    {
      "type": "Rule",
      "antecedent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "b"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      },
      "consequent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "c"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      }
    }
  ],
  "builtins": []
}
[N3LogicReasoner][DEBUG] N3LogicReasoner: Parsed rules after parsing: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][DEBUG] N3LogicReasoner: Parsed rules after parsing: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] Parsed triples after parsing: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] Parsed triples after parsing: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] N3LogicReasoner: Rule #0 antecedent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] N3LogicReasoner: Rule #0 antecedent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] N3LogicReasoner: Rule #0 consequent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] N3LogicReasoner: Rule #0 consequent triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: merging builtins []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: merging builtins []
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: document.builtins after merge [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology: document.builtins after merge [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins after loadOntology: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins after loadOntology: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] document.builtins after loadOntology: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG][LOGGING] document.builtins after loadOntology: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] Parsed rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][DEBUG] Parsed rules: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterLoadOntology [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        }
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterLoadOntology [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        }
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterLoadOntology args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        }
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterLoadOntology args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        }
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterLoadOntology",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "1"
          }
        }
      ],
      "rules": [
        {
          "type": "Rule",
          "antecedent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "b"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          },
          "consequent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "c"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          }
        }
      ],
      "builtins": [
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterLoadOntology",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "1"
          }
        }
      ],
      "rules": [
        {
          "type": "Rule",
          "antecedent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "b"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          },
          "consequent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "c"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          }
        }
      ],
      "builtins": [
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterLoadOntology
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterLoadOntology
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterLoadOntology
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterLoadOntology
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology finished
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] loadOntology finished
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason() called
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason() called
[N3LogicReasoner][DEBUG] [REASONER] Starting reason() method. Current builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [REASONER] Starting reason() method. Current builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: merging builtins []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: merging builtins []
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: document.builtins after merge [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: document.builtins after merge [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before reasoning: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] customBuiltins before reasoning: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins before reasoning: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] document.builtins before reasoning: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] Merged builtins for reasoning: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] Merged builtins for reasoning: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] Starting reasoning {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ],
  "rules": [
    {
      "type": "Rule",
      "antecedent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "b"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      },
      "consequent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "c"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      }
    }
  ]
}
[N3LogicReasoner][DEBUG] Starting reasoning {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ],
  "rules": [
    {
      "type": "Rule",
      "antecedent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "b"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      },
      "consequent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "c"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      }
    }
  ]
}
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: beforeReason [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        },
        "_id": 1,
        "_provenance": "asserted"
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: beforeReason [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        },
        "_id": 1,
        "_provenance": "asserted"
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: beforeReason args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        },
        "_id": 1,
        "_provenance": "asserted"
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: beforeReason args: [
  {
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        },
        "_id": 1,
        "_provenance": "asserted"
      }
    ],
    "rules": [
      {
        "type": "Rule",
        "antecedent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "b"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        },
        "consequent": {
          "type": "Formula",
          "triples": [
            {
              "subject": {
                "type": "IRI",
                "value": "a"
              },
              "predicate": {
                "type": "IRI",
                "value": "c"
              },
              "object": {
                "type": "Variable",
                "value": "x"
              }
            }
          ]
        }
      }
    ],
    "builtins": [
      {
        "uri": "http://www.w3.org/2000/10/swap/log#not",
        "arity": 1,
        "description": "log:not(x) is true if x is false"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#implies",
        "arity": 2,
        "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
        "arity": 2,
        "description": "log:equalTo(x, y) is true if x === y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#or",
        "arity": 2,
        "description": "log:or(x, y) is true if x or y is true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#and",
        "arity": 2,
        "description": "log:and(x, y) is true if both x and y are true"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#xor",
        "arity": 2,
        "description": "log:xor(x, y) is true if x and y differ"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#if",
        "arity": 3,
        "description": "log:if(cond, then, else) returns then if cond is true, else else"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/log#distinct",
        "arity": 2,
        "description": "log:distinct(x, y) is true if x != y"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
        "arity": 1,
        "description": "type:isLiteral(x) is true if x is a literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
        "arity": 1,
        "description": "type:isIRI(x) is true if x is an IRI"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
        "arity": 1,
        "description": "type:isBlank(x) is true if x is a blank node"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toString",
        "arity": 1,
        "description": "type:toString(x) returns x as string"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
        "arity": 1,
        "description": "type:toNumber(x) returns x as number literal"
      },
      {
        "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
        "arity": 1,
        "description": "type:toBoolean(x) returns x as boolean literal"
      },
      {
        "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
        "arity": 2,
        "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
      },
      {
        "uri": "http://www.w3.org/2002/07/owl#sameAs",
        "arity": 2,
        "description": "owl:sameAs(x, y) is true if x and y are the same"
      }
    ]
  }
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "beforeReason",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "1"
          },
          "_id": 1,
          "_provenance": "asserted"
        }
      ],
      "rules": [
        {
          "type": "Rule",
          "antecedent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "b"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          },
          "consequent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "c"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          }
        }
      ],
      "builtins": [
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "beforeReason",
  "args": [
    {
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Literal",
            "value": "1"
          },
          "_id": 1,
          "_provenance": "asserted"
        }
      ],
      "rules": [
        {
          "type": "Rule",
          "antecedent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "b"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          },
          "consequent": {
            "type": "Formula",
            "triples": [
              {
                "subject": {
                  "type": "IRI",
                  "value": "a"
                },
                "predicate": {
                  "type": "IRI",
                  "value": "c"
                },
                "object": {
                  "type": "Variable",
                  "value": "x"
                }
              }
            ]
          }
        }
      ],
      "builtins": [
        {
          "uri": "http://www.w3.org/2000/10/swap/log#not",
          "arity": 1,
          "description": "log:not(x) is true if x is false"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#implies",
          "arity": 2,
          "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
          "arity": 2,
          "description": "log:equalTo(x, y) is true if x === y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#or",
          "arity": 2,
          "description": "log:or(x, y) is true if x or y is true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#and",
          "arity": 2,
          "description": "log:and(x, y) is true if both x and y are true"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#xor",
          "arity": 2,
          "description": "log:xor(x, y) is true if x and y differ"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#if",
          "arity": 3,
          "description": "log:if(cond, then, else) returns then if cond is true, else else"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/log#distinct",
          "arity": 2,
          "description": "log:distinct(x, y) is true if x != y"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
          "arity": 1,
          "description": "type:isLiteral(x) is true if x is a literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
          "arity": 1,
          "description": "type:isIRI(x) is true if x is an IRI"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
          "arity": 1,
          "description": "type:isBlank(x) is true if x is a blank node"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toString",
          "arity": 1,
          "description": "type:toString(x) returns x as string"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
          "arity": 1,
          "description": "type:toNumber(x) returns x as number literal"
        },
        {
          "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
          "arity": 1,
          "description": "type:toBoolean(x) returns x as boolean literal"
        },
        {
          "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
          "arity": 2,
          "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
        },
        {
          "uri": "http://www.w3.org/2002/07/owl#sameAs",
          "arity": 2,
          "description": "owl:sameAs(x, y) is true if x and y are the same"
        }
      ]
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for beforeReason
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook beforeReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook beforeReason
[N3LogicReasoner][DEBUG] Initial working triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] Initial working triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <b> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <b> "1" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <b> "1" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <b> "1" .
[N3LogicReasoner][DEBUG] Adding initial triple to inferred set: <a> <b> "1" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][DEBUG] Adding initial triple to inferred set: <a> <b> "1" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Reasoning iteration 1 START
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Reasoning iteration 1 START
[N3LogicReasoner][DEBUG] 
=== Reasoning iteration 1 START ===
[N3LogicReasoner][DEBUG] 
=== Reasoning iteration 1 START ===
[N3LogicReasoner][DEBUG] Current triple store at start of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] Current triple store at start of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Evaluating rule #0
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Evaluating rule #0
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Evaluating rule #0: {"type":"Rule","antecedent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]},"consequent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Evaluating rule #0: {"type":"Rule","antecedent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]},"consequent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]}}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Matching antecedent for rule #0
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Matching antecedent for rule #0
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Matching antecedent for rule #0: {"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Matching antecedent for rule #0: {"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]}
[N3LogicReasoner][TRACE] matchFormula called {
  "formula": {
    "type": "Formula",
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Variable",
          "value": "x"
        }
      }
    ]
  },
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] matchFormula called {
  "formula": {
    "type": "Formula",
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Variable",
          "value": "x"
        }
      }
    ]
  },
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] Formula type is Formula, matching antecedent: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] Formula type is Formula, matching antecedent: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent called: {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent called: {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent called with: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}] [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent called with: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}] [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Checking pattern triple # 0 : {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Checking pattern triple # 0 : {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Pattern triple details: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Pattern triple details: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Triple matching logic entered: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Triple matching logic entered: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Attempting builtin match for triple predicate: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Attempting builtin match for triple predicate: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] All builtins at this point: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] All builtins at this point: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin candidate URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin candidate URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin match found for predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin match found for predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin match found for predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin match found for predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtin found: false for predicateUri: b triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtin found: false for predicateUri: b triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin found: false for predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin found: false for predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][TRACE] matchTriple called {
  "pattern": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
}
[N3LogicReasoner][TRACE] matchTriple called {
  "pattern": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "a"
  },
  "value": {
    "type": "IRI",
    "value": "a"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "a"
  },
  "value": {
    "type": "IRI",
    "value": "a"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "a"
} {
  "type": "IRI",
  "value": "a"
}
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "a"
} {
  "type": "IRI",
  "value": "a"
}
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "b"
  },
  "value": {
    "type": "IRI",
    "value": "b"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "b"
  },
  "value": {
    "type": "IRI",
    "value": "b"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "b"
}
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "b"
}
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "Variable",
    "value": "x"
  },
  "value": {
    "type": "Literal",
    "value": "1"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "Variable",
    "value": "x"
  },
  "value": {
    "type": "Literal",
    "value": "1"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is variable: x
[N3LogicReasoner][TRACE] Pattern is variable: x
[N3LogicReasoner][TRACE] Binding variable: x to value: {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][TRACE] Binding variable: x to value: {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][TRACE] matchTriple succeeded, bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] matchTriple succeeded, bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data triple matched: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"} bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data triple matched: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"} bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Data triple matched: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
} bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Data triple matched: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
} bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: []
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: []
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: patterns: []
[N3LogicReasoner][TRACE] matchAntecedent: patterns: []
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    }
  ]
}
[N3LogicReasoner][TRACE] No patterns left, returning [{}]
[N3LogicReasoner][TRACE] No patterns left, returning [{}]
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Added result bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Added result bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] matchAntecedent returning results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] matchAntecedent returning results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent returning results: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent returning results: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent result: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent result: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent result: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent result: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings list from matchFormula for rule #0: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings list from matchFormula for rule #0: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings list from matchFormula for rule #0: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings list from matchFormula for rule #0: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings #0 before evaluateBuiltins for rule #0: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings #0 before evaluateBuiltins for rule #0: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings #0 before evaluateBuiltins for rule #0: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings #0 before evaluateBuiltins for rule #0: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins called: {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins called: {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] evaluateBuiltins: triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] evaluateBuiltins: bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins called {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][DEBUG] evaluateBuiltins called {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking builtin for predicate: b Found: false Function:  Typeof: 
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking builtin for predicate: b Found: false Function:  Typeof: 
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins returning true
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins returning true
[N3LogicReasoner][DEBUG] evaluateBuiltins returning true
[N3LogicReasoner][DEBUG] evaluateBuiltins returning true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiating consequent triple #0 for rule #0
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiating consequent triple #0 for rule #0
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiating consequent triple #0 for rule #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}} with bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiating consequent triple #0 for rule #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}} with bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple called: {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple called: {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][DEBUG] instantiateTriple called {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][DEBUG] instantiateTriple called {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][DEBUG] Substituting variable in triple: x with {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][DEBUG] Substituting variable in triple: x with {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][DEBUG] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiated triple for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiated triple for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiated triple for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiated triple for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <c> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <c> "1" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <c> "1" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <c> "1" .
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Adding new inferred triple for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
} Key: <a> <c> "1" .
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Adding new inferred triple for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
} Key: <a> <c> "1" .
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Adding new inferred triple for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}} Key: <a> <c> "1" .
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Adding new inferred triple for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}} Key: <a> <c> "1" .
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterRuleApplied [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  },
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterRuleApplied [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  },
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterRuleApplied args: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  },
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterRuleApplied args: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  },
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterRuleApplied",
  "args": [
    {
      "type": "Rule",
      "antecedent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "b"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      },
      "consequent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "c"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      }
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    },
    {
      "x": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterRuleApplied",
  "args": [
    {
      "type": "Rule",
      "antecedent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "b"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      },
      "consequent": {
        "type": "Formula",
        "triples": [
          {
            "subject": {
              "type": "IRI",
              "value": "a"
            },
            "predicate": {
              "type": "IRI",
              "value": "c"
            },
            "object": {
              "type": "Variable",
              "value": "x"
            }
          }
        ]
      }
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    },
    {
      "x": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: firing hook {
  "hookName": "afterRuleApplied"
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: firing hook {
  "hookName": "afterRuleApplied"
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Firing hook: afterRuleApplied args: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  },
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Firing hook: afterRuleApplied args: [
  {
    "type": "Rule",
    "antecedent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "b"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    },
    "consequent": {
      "type": "Formula",
      "triples": [
        {
          "subject": {
            "type": "IRI",
            "value": "a"
          },
          "predicate": {
            "type": "IRI",
            "value": "c"
          },
          "object": {
            "type": "Variable",
            "value": "x"
          }
        }
      ]
    }
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  },
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook finished: {
  "hookName": "afterRuleApplied"
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook finished: {
  "hookName": "afterRuleApplied"
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterRuleApplied
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterRuleApplied
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] New triples inferred in iteration 1: [
  "<a> <c> \"1\" ."
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] New triples inferred in iteration 1: [
  "<a> <c> \"1\" ."
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] New triples inferred in iteration 1: [
  "<a> <c> \"1\" ."
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] New triples inferred in iteration 1: [
  "<a> <c> \"1\" ."
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Rules fired in iteration 1: [
  0
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Rules fired in iteration 1: [
  0
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Rules fired in iteration 1: [
  0
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Rules fired in iteration 1: [
  0
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Current triple store at end of iteration 1: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] === Reasoning iteration 1 END. changed=true ===
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] === Reasoning iteration 1 END. changed=true ===
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] === Reasoning iteration 1 END. changed=true ===

[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] === Reasoning iteration 1 END. changed=true ===

[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Reasoning iteration 2 START
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Reasoning iteration 2 START
[N3LogicReasoner][DEBUG] 
=== Reasoning iteration 2 START ===
[N3LogicReasoner][DEBUG] 
=== Reasoning iteration 2 START ===
[N3LogicReasoner][DEBUG] Current triple store at start of iteration 2: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] Current triple store at start of iteration 2: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Evaluating rule #0
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Evaluating rule #0
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Evaluating rule #0: {"type":"Rule","antecedent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]},"consequent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Evaluating rule #0: {"type":"Rule","antecedent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]},"consequent":{"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}}]}}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Matching antecedent for rule #0
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Matching antecedent for rule #0
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Matching antecedent for rule #0: {"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Matching antecedent for rule #0: {"type":"Formula","triples":[{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}]}
[N3LogicReasoner][TRACE] matchFormula called {
  "formula": {
    "type": "Formula",
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Variable",
          "value": "x"
        }
      }
    ]
  },
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] matchFormula called {
  "formula": {
    "type": "Formula",
    "triples": [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Variable",
          "value": "x"
        }
      }
    ]
  },
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] Formula type is Formula, matching antecedent: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] Formula type is Formula, matching antecedent: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent called: {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent called: {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [builtinsManager] mergeBuiltins called: [] Resulting merged builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "typeofApply": "function"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "typeofApply": "function"
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent called with: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}] [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"},{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent called with: [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}] [{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"},{"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Using mergedBuiltins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: patterns: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Checking pattern triple # 0 : {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Checking pattern triple # 0 : {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Pattern triple details: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Pattern triple details: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Triple matching logic entered: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Triple matching logic entered: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Attempting builtin match for triple predicate: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Attempting builtin match for triple predicate: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] All builtins at this point: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] All builtins at this point: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin candidate URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin candidate URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#not against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#implies against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#equalTo against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#or against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#and against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#xor against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#if against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/log#distinct against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isLiteral against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isIRI against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#isBlank against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toString against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toNumber against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2000/10/swap/type#toBoolean against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/1999/02/22-rdf-syntax-ns#type against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Checking builtin candidate: http://www.w3.org/2002/07/owl#sameAs against predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin match found for predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin match found for predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin match found for predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin match found for predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtin found: false for predicateUri: b triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtin found: false for predicateUri: b triple: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Variable","value":"x"}}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin found: false for predicateUri: b
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Builtin found: false for predicateUri: b
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][TRACE] [MATCHER][TRACE] No builtin found, matching pattern triple against data triples.
[N3LogicReasoner][TRACE] matchTriple called {
  "pattern": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
}
[N3LogicReasoner][TRACE] matchTriple called {
  "pattern": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  }
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "a"
  },
  "value": {
    "type": "IRI",
    "value": "a"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "a"
  },
  "value": {
    "type": "IRI",
    "value": "a"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "a"
} {
  "type": "IRI",
  "value": "a"
}
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "a"
} {
  "type": "IRI",
  "value": "a"
}
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "b"
  },
  "value": {
    "type": "IRI",
    "value": "b"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "b"
  },
  "value": {
    "type": "IRI",
    "value": "b"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "b"
}
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "b"
}
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "Variable",
    "value": "x"
  },
  "value": {
    "type": "Literal",
    "value": "1"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "Variable",
    "value": "x"
  },
  "value": {
    "type": "Literal",
    "value": "1"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is variable: x
[N3LogicReasoner][TRACE] Pattern is variable: x
[N3LogicReasoner][TRACE] Binding variable: x to value: {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][TRACE] Binding variable: x to value: {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][TRACE] matchTriple succeeded, bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] matchTriple succeeded, bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data triple matched: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"} bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data triple matched: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"b"},"object":{"type":"Literal","value":"1"},"_id":1,"_provenance":"asserted"} bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Data triple matched: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
} bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Data triple matched: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  },
  "_id": 1,
  "_provenance": "asserted"
} bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtins available at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: []
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Patterns: []
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG][LOGGING] Builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent called with patterns: [] data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
] builtins: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] Builtins at match time: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: patterns: []
[N3LogicReasoner][TRACE] matchAntecedent: patterns: []
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: data: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtins: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent: builtin URIs: [
  "http://www.w3.org/2000/10/swap/log#not",
  "http://www.w3.org/2000/10/swap/log#implies",
  "http://www.w3.org/2000/10/swap/log#equalTo",
  "http://www.w3.org/2000/10/swap/log#or",
  "http://www.w3.org/2000/10/swap/log#and",
  "http://www.w3.org/2000/10/swap/log#xor",
  "http://www.w3.org/2000/10/swap/log#if",
  "http://www.w3.org/2000/10/swap/log#distinct",
  "http://www.w3.org/2000/10/swap/type#isLiteral",
  "http://www.w3.org/2000/10/swap/type#isIRI",
  "http://www.w3.org/2000/10/swap/type#isBlank",
  "http://www.w3.org/2000/10/swap/type#toString",
  "http://www.w3.org/2000/10/swap/type#toNumber",
  "http://www.w3.org/2000/10/swap/type#toBoolean",
  "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
  "http://www.w3.org/2002/07/owl#sameAs"
]
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] matchAntecedent called {
  "patterns": [],
  "data": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
}
[N3LogicReasoner][TRACE] No patterns left, returning [{}]
[N3LogicReasoner][TRACE] No patterns left, returning [{}]
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Added result bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [MATCHER][TRACE] Added result bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] matchTriple called {
  "pattern": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][TRACE] matchTriple called {
  "pattern": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "a"
  },
  "value": {
    "type": "IRI",
    "value": "a"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "a"
  },
  "value": {
    "type": "IRI",
    "value": "a"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "a"
} {
  "type": "IRI",
  "value": "a"
}
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "a"
} {
  "type": "IRI",
  "value": "a"
}
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termEquals: object equality true
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "b"
  },
  "value": {
    "type": "IRI",
    "value": "c"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] termMatch called {
  "pattern": {
    "type": "IRI",
    "value": "b"
  },
  "value": {
    "type": "IRI",
    "value": "c"
  },
  "bindings": {}
}
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] Pattern is not variable, checking term equality
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "c"
}
[N3LogicReasoner][TRACE] termEquals input: {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "c"
}
[N3LogicReasoner][TRACE] termEquals: object equality false
[N3LogicReasoner][TRACE] termEquals: object equality false
[N3LogicReasoner][TRACE] matchTriple: predicate did not match {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "c"
}
[N3LogicReasoner][TRACE] matchTriple: predicate did not match {
  "type": "IRI",
  "value": "b"
} {
  "type": "IRI",
  "value": "c"
}
[N3LogicReasoner][DEBUG] matchAntecedent returning results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] matchAntecedent returning results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent returning results: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent returning results: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [MATCHER][DEBUG] matchAntecedent: final results: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent result: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] matchAntecedent result: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent result: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] matchAntecedent result: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings list from matchFormula for rule #0: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings list from matchFormula for rule #0: [
  {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings list from matchFormula for rule #0: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings list from matchFormula for rule #0: [{"x":{"type":"Literal","value":"1"}}]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings #0 before evaluateBuiltins for rule #0: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Bindings #0 before evaluateBuiltins for rule #0: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings #0 before evaluateBuiltins for rule #0: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Bindings #0 before evaluateBuiltins for rule #0: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins called: {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins called: {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] evaluateBuiltins: triples: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  }
]
[N3LogicReasoner][DEBUG] evaluateBuiltins: bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: bindings: {
  "x": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins called {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][DEBUG] evaluateBuiltins called {
  "triples": [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Variable",
        "value": "x"
      }
    }
  ],
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  },
  "builtins": [
    {
      "uri": "http://www.w3.org/2000/10/swap/log#not",
      "arity": 1,
      "description": "log:not(x) is true if x is false"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#implies",
      "arity": 2,
      "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
      "arity": 2,
      "description": "log:equalTo(x, y) is true if x === y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#or",
      "arity": 2,
      "description": "log:or(x, y) is true if x or y is true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#and",
      "arity": 2,
      "description": "log:and(x, y) is true if both x and y are true"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#xor",
      "arity": 2,
      "description": "log:xor(x, y) is true if x and y differ"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#if",
      "arity": 3,
      "description": "log:if(cond, then, else) returns then if cond is true, else else"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/log#distinct",
      "arity": 2,
      "description": "log:distinct(x, y) is true if x != y"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
      "arity": 1,
      "description": "type:isLiteral(x) is true if x is a literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
      "arity": 1,
      "description": "type:isIRI(x) is true if x is an IRI"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
      "arity": 1,
      "description": "type:isBlank(x) is true if x is a blank node"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toString",
      "arity": 1,
      "description": "type:toString(x) returns x as string"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
      "arity": 1,
      "description": "type:toNumber(x) returns x as number literal"
    },
    {
      "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
      "arity": 1,
      "description": "type:toBoolean(x) returns x as boolean literal"
    },
    {
      "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "arity": 2,
      "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
    },
    {
      "uri": "http://www.w3.org/2002/07/owl#sameAs",
      "arity": 2,
      "description": "owl:sameAs(x, y) is true if x and y are the same"
    }
  ]
}
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Builtins full array: [
  {
    "uri": "http://www.w3.org/2000/10/swap/log#not",
    "arity": 1,
    "description": "log:not(x) is true if x is false"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#implies",
    "arity": 2,
    "description": "log:implies(x, y) is true if x implies y (handled by rule engine)"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#equalTo",
    "arity": 2,
    "description": "log:equalTo(x, y) is true if x === y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#or",
    "arity": 2,
    "description": "log:or(x, y) is true if x or y is true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#and",
    "arity": 2,
    "description": "log:and(x, y) is true if both x and y are true"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#xor",
    "arity": 2,
    "description": "log:xor(x, y) is true if x and y differ"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#if",
    "arity": 3,
    "description": "log:if(cond, then, else) returns then if cond is true, else else"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/log#distinct",
    "arity": 2,
    "description": "log:distinct(x, y) is true if x != y"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isLiteral",
    "arity": 1,
    "description": "type:isLiteral(x) is true if x is a literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isIRI",
    "arity": 1,
    "description": "type:isIRI(x) is true if x is an IRI"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#isBlank",
    "arity": 1,
    "description": "type:isBlank(x) is true if x is a blank node"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toString",
    "arity": 1,
    "description": "type:toString(x) returns x as string"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toNumber",
    "arity": 1,
    "description": "type:toNumber(x) returns x as number literal"
  },
  {
    "uri": "http://www.w3.org/2000/10/swap/type#toBoolean",
    "arity": 1,
    "description": "type:toBoolean(x) returns x as boolean literal"
  },
  {
    "uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    "arity": 2,
    "description": "rdf:type(x, y) is true if x is of type y (handled by triple matching)"
  },
  {
    "uri": "http://www.w3.org/2002/07/owl#sameAs",
    "arity": 2,
    "description": "owl:sameAs(x, y) is true if x and y are the same"
  }
]
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][DEBUG] [EVALBUILTINS][CUSTOM] Triple predicate: {"type":"IRI","value":"b"}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][DEBUG] evaluateBuiltins: checking triple: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "b"
  },
  "object": {
    "type": "Variable",
    "value": "x"
  }
}
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking builtin for predicate: b Found: false Function:  Typeof: 
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] Checking builtin for predicate: b Found: false Function:  Typeof: 
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins returning true
[N3LogicReasoner][TRACE] [builtinEvaluator][TRACE] evaluateBuiltins returning true
[N3LogicReasoner][DEBUG] evaluateBuiltins returning true
[N3LogicReasoner][DEBUG] evaluateBuiltins returning true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] evaluateBuiltins result for rule #0, bindings #0: true
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiating consequent triple #0 for rule #0
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiating consequent triple #0 for rule #0
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiating consequent triple #0 for rule #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}} with bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiating consequent triple #0 for rule #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Variable","value":"x"}} with bindings: {"x":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple called: {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple called: {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][DEBUG] instantiateTriple called {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][DEBUG] instantiateTriple called {
  "triple": {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Variable",
      "value": "x"
    }
  },
  "bindings": {
    "x": {
      "type": "Literal",
      "value": "1"
    }
  }
}
[N3LogicReasoner][DEBUG] Substituting variable in triple: x with {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][DEBUG] Substituting variable in triple: x with {
  "type": "Literal",
  "value": "1"
}
[N3LogicReasoner][DEBUG] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] instantiateTriple result: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiated triple for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Instantiated triple for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiated triple for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Instantiated triple for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] tripleToString input: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString called: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <c> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] tripleToString: result <a> <c> "1" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <c> "1" .
[N3LogicReasoner][TRACE] tripleToString output: <a> <c> "1" .
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Checking if triple is already inferred for rule #0, consIdx #0: <a> <c> "1" . {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Triple already present, skipping for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
} Key: <a> <c> "1" .
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Triple already present, skipping for rule #0, consIdx #0: {
  "subject": {
    "type": "IRI",
    "value": "a"
  },
  "predicate": {
    "type": "IRI",
    "value": "c"
  },
  "object": {
    "type": "Literal",
    "value": "1"
  }
} Key: <a> <c> "1" .
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Triple already present, skipping for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}} Key: <a> <c> "1" .
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Triple already present, skipping for rule #0, consIdx #0: {"subject":{"type":"IRI","value":"a"},"predicate":{"type":"IRI","value":"c"},"object":{"type":"Literal","value":"1"}} Key: <a> <c> "1" .
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] New triples inferred in iteration 2: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] New triples inferred in iteration 2: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] New triples inferred in iteration 2: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] New triples inferred in iteration 2: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Rules fired in iteration 2: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Rules fired in iteration 2: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Rules fired in iteration 2: []
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Rules fired in iteration 2: []
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Current triple store at end of iteration 2: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] Current triple store at end of iteration 2: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Current triple store at end of iteration 2: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] Current triple store at end of iteration 2: [
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "b"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    },
    "_id": 1,
    "_provenance": "asserted"
  },
  {
    "subject": {
      "type": "IRI",
      "value": "a"
    },
    "predicate": {
      "type": "IRI",
      "value": "c"
    },
    "object": {
      "type": "Literal",
      "value": "1"
    }
  }
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] === Reasoning iteration 2 END. changed=false ===
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] === Reasoning iteration 2 END. changed=false ===
[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] === Reasoning iteration 2 END. changed=false ===

[N3LogicReasoner][DEBUG] [N3LogicReasoner][DEBUG] === Reasoning iteration 2 END. changed=false ===

[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterReason [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
]
[N3LogicReasoner][TRACE] [N3LogicReasoner] runHook called: afterReason [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterReason args: [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
]
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] About to fire hook: afterReason args: [
  [
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "b"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      },
      "_id": 1,
      "_provenance": "asserted"
    },
    {
      "subject": {
        "type": "IRI",
        "value": "a"
      },
      "predicate": {
        "type": "IRI",
        "value": "c"
      },
      "object": {
        "type": "Literal",
        "value": "1"
      }
    }
  ]
]
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterReason",
  "args": [
    [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "c"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        }
      }
    ]
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook called: {
  "hookName": "afterReason",
  "args": [
    [
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "b"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        },
        "_id": 1,
        "_provenance": "asserted"
      },
      {
        "subject": {
          "type": "IRI",
          "value": "a"
        },
        "predicate": {
          "type": "IRI",
          "value": "c"
        },
        "object": {
          "type": "Literal",
          "value": "1"
        }
      }
    ]
  ]
}
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterReason
[N3LogicReasoner][TRACE] [hooks][TRACE] runHook: no hooks registered for afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][HOOKS] Finished firing hook: afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook afterReason
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: after runHook afterReason
[N3LogicReasoner][DEBUG] Reasoning complete. Inferred triples: [
  "<a> <b> \"1\" .",
  "<a> <c> \"1\" ."
]
[N3LogicReasoner][DEBUG] Reasoning complete. Inferred triples: [
  "<a> <b> \"1\" .",
  "<a> <c> \"1\" ."
]
[N3LogicReasoner][TRACE] stringToTriple input: <a> <b> "1" .
[N3LogicReasoner][TRACE] stringToTriple input: <a> <b> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <b> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <b> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<b>",
  "object": "\"1\""
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<b>",
  "object": "\"1\""
}
[N3LogicReasoner][TRACE] stringToTriple input: <a> <c> "1" .
[N3LogicReasoner][TRACE] stringToTriple input: <a> <c> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <c> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple called: <a> <c> "1" .
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<c>",
  "object": "\"1\""
}
[N3LogicReasoner][TRACE] [tripleUtils][TRACE] stringToTriple: result {
  "subject": "<a>",
  "predicate": "<c>",
  "object": "\"1\""
}
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: finished, returning result
[N3LogicReasoner][TRACE] [N3LogicReasoner][TRACE] reason: finished, returning result
